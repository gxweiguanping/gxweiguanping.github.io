<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>垃圾收集器 | Gpingの知识库</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="记录学习路上的点点滴滴">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/assets/css/0.styles.18a91880.css" as="style"><link rel="preload" href="/assets/js/app.57e44612.js" as="script"><link rel="preload" href="/assets/js/2.ea24d1ee.js" as="script"><link rel="preload" href="/assets/js/31.044a932c.js" as="script"><link rel="prefetch" href="/assets/js/10.87a7fc9a.js"><link rel="prefetch" href="/assets/js/100.1dde94ac.js"><link rel="prefetch" href="/assets/js/101.a9e60cd0.js"><link rel="prefetch" href="/assets/js/102.41fc30c1.js"><link rel="prefetch" href="/assets/js/103.d66d2d71.js"><link rel="prefetch" href="/assets/js/104.22cb586e.js"><link rel="prefetch" href="/assets/js/105.2e7087a4.js"><link rel="prefetch" href="/assets/js/106.f3ea04f4.js"><link rel="prefetch" href="/assets/js/107.1fe76475.js"><link rel="prefetch" href="/assets/js/108.5419a3bf.js"><link rel="prefetch" href="/assets/js/109.25f5a5d7.js"><link rel="prefetch" href="/assets/js/11.04f09971.js"><link rel="prefetch" href="/assets/js/110.859d6308.js"><link rel="prefetch" href="/assets/js/111.1007812c.js"><link rel="prefetch" href="/assets/js/112.1e3ac86b.js"><link rel="prefetch" href="/assets/js/113.39632362.js"><link rel="prefetch" href="/assets/js/114.cd109b57.js"><link rel="prefetch" href="/assets/js/115.738c1531.js"><link rel="prefetch" href="/assets/js/116.8afaf129.js"><link rel="prefetch" href="/assets/js/117.fc53579f.js"><link rel="prefetch" href="/assets/js/118.21a1f8c4.js"><link rel="prefetch" href="/assets/js/119.0a6295f3.js"><link rel="prefetch" href="/assets/js/12.39c155f1.js"><link rel="prefetch" href="/assets/js/120.b52ae2c0.js"><link rel="prefetch" href="/assets/js/121.a7d78631.js"><link rel="prefetch" href="/assets/js/122.a28e6a23.js"><link rel="prefetch" href="/assets/js/123.c426392a.js"><link rel="prefetch" href="/assets/js/124.c522482b.js"><link rel="prefetch" href="/assets/js/125.92a0ca2c.js"><link rel="prefetch" href="/assets/js/126.c7e332fc.js"><link rel="prefetch" href="/assets/js/127.09fed274.js"><link rel="prefetch" href="/assets/js/128.5b2b776f.js"><link rel="prefetch" href="/assets/js/129.78e15024.js"><link rel="prefetch" href="/assets/js/13.2b02d3de.js"><link rel="prefetch" href="/assets/js/130.97b2a44d.js"><link rel="prefetch" href="/assets/js/131.0453b852.js"><link rel="prefetch" href="/assets/js/132.1d3bd373.js"><link rel="prefetch" href="/assets/js/133.445fa178.js"><link rel="prefetch" href="/assets/js/134.10a04df0.js"><link rel="prefetch" href="/assets/js/135.7966ce33.js"><link rel="prefetch" href="/assets/js/136.03b5e675.js"><link rel="prefetch" href="/assets/js/137.5eed4831.js"><link rel="prefetch" href="/assets/js/138.ed4fba77.js"><link rel="prefetch" href="/assets/js/139.8eb46152.js"><link rel="prefetch" href="/assets/js/14.8881736c.js"><link rel="prefetch" href="/assets/js/140.08e196c0.js"><link rel="prefetch" href="/assets/js/141.b18b66b6.js"><link rel="prefetch" href="/assets/js/142.03a0879c.js"><link rel="prefetch" href="/assets/js/143.22fdbb7b.js"><link rel="prefetch" href="/assets/js/144.31189f97.js"><link rel="prefetch" href="/assets/js/145.75b2fd40.js"><link rel="prefetch" href="/assets/js/146.dbb475d1.js"><link rel="prefetch" href="/assets/js/147.cf107953.js"><link rel="prefetch" href="/assets/js/148.f9449ca9.js"><link rel="prefetch" href="/assets/js/149.6960a659.js"><link rel="prefetch" href="/assets/js/15.b4b6d9e8.js"><link rel="prefetch" href="/assets/js/150.f4a4a9e2.js"><link rel="prefetch" href="/assets/js/151.df5e1fda.js"><link rel="prefetch" href="/assets/js/152.b3ebe11a.js"><link rel="prefetch" href="/assets/js/153.fe7d6b3f.js"><link rel="prefetch" href="/assets/js/154.aeb16b2b.js"><link rel="prefetch" href="/assets/js/155.649eeac2.js"><link rel="prefetch" href="/assets/js/156.72888c77.js"><link rel="prefetch" href="/assets/js/157.dc67f246.js"><link rel="prefetch" href="/assets/js/158.467b9e3c.js"><link rel="prefetch" href="/assets/js/159.384e3132.js"><link rel="prefetch" href="/assets/js/16.e6a03cb0.js"><link rel="prefetch" href="/assets/js/160.75f72beb.js"><link rel="prefetch" href="/assets/js/161.c4bf3ed6.js"><link rel="prefetch" href="/assets/js/162.4e905989.js"><link rel="prefetch" href="/assets/js/163.e10e10ec.js"><link rel="prefetch" href="/assets/js/164.8c3e42dc.js"><link rel="prefetch" href="/assets/js/165.c9509c25.js"><link rel="prefetch" href="/assets/js/166.875c96b9.js"><link rel="prefetch" href="/assets/js/167.ac323741.js"><link rel="prefetch" href="/assets/js/168.6cff22a8.js"><link rel="prefetch" href="/assets/js/169.9a12d5c9.js"><link rel="prefetch" href="/assets/js/17.430c4645.js"><link rel="prefetch" href="/assets/js/170.bb307927.js"><link rel="prefetch" href="/assets/js/171.40dbf2b6.js"><link rel="prefetch" href="/assets/js/172.a11d0b5a.js"><link rel="prefetch" href="/assets/js/173.86064fd6.js"><link rel="prefetch" href="/assets/js/174.1cacb422.js"><link rel="prefetch" href="/assets/js/175.622de80a.js"><link rel="prefetch" href="/assets/js/176.de8449aa.js"><link rel="prefetch" href="/assets/js/177.cb9b484d.js"><link rel="prefetch" href="/assets/js/178.9f5c2068.js"><link rel="prefetch" href="/assets/js/179.ffff651e.js"><link rel="prefetch" href="/assets/js/18.3bb48241.js"><link rel="prefetch" href="/assets/js/180.09a9c21e.js"><link rel="prefetch" href="/assets/js/181.26ed76ed.js"><link rel="prefetch" href="/assets/js/182.17a77c05.js"><link rel="prefetch" href="/assets/js/183.53fafefd.js"><link rel="prefetch" href="/assets/js/184.a67c9279.js"><link rel="prefetch" href="/assets/js/185.5ef13915.js"><link rel="prefetch" href="/assets/js/186.80f2394f.js"><link rel="prefetch" href="/assets/js/187.9966ad44.js"><link rel="prefetch" href="/assets/js/188.03ff6401.js"><link rel="prefetch" href="/assets/js/189.0673741c.js"><link rel="prefetch" href="/assets/js/19.1a1d4b97.js"><link rel="prefetch" href="/assets/js/190.b00a4558.js"><link rel="prefetch" href="/assets/js/191.ffb3dc84.js"><link rel="prefetch" href="/assets/js/192.a1c08248.js"><link rel="prefetch" href="/assets/js/193.12c63e53.js"><link rel="prefetch" href="/assets/js/194.f33b52de.js"><link rel="prefetch" href="/assets/js/195.33c636d4.js"><link rel="prefetch" href="/assets/js/196.6c3d5dd1.js"><link rel="prefetch" href="/assets/js/197.30d1c025.js"><link rel="prefetch" href="/assets/js/198.452ad7b8.js"><link rel="prefetch" href="/assets/js/199.e5ef0a61.js"><link rel="prefetch" href="/assets/js/20.a60725d3.js"><link rel="prefetch" href="/assets/js/200.686c1f4c.js"><link rel="prefetch" href="/assets/js/201.bc89ccf8.js"><link rel="prefetch" href="/assets/js/202.59ba3183.js"><link rel="prefetch" href="/assets/js/203.bcd865f8.js"><link rel="prefetch" href="/assets/js/204.8d50c324.js"><link rel="prefetch" href="/assets/js/205.742dccae.js"><link rel="prefetch" href="/assets/js/206.88d6037a.js"><link rel="prefetch" href="/assets/js/207.190776c5.js"><link rel="prefetch" href="/assets/js/208.fa870ec7.js"><link rel="prefetch" href="/assets/js/209.0ead087a.js"><link rel="prefetch" href="/assets/js/21.6c56b6f5.js"><link rel="prefetch" href="/assets/js/210.4793eafd.js"><link rel="prefetch" href="/assets/js/211.d4701451.js"><link rel="prefetch" href="/assets/js/212.960f82e6.js"><link rel="prefetch" href="/assets/js/213.06afd767.js"><link rel="prefetch" href="/assets/js/214.7b98451d.js"><link rel="prefetch" href="/assets/js/215.78151312.js"><link rel="prefetch" href="/assets/js/216.d2f394e3.js"><link rel="prefetch" href="/assets/js/217.d6868358.js"><link rel="prefetch" href="/assets/js/218.74bb756c.js"><link rel="prefetch" href="/assets/js/219.6239b512.js"><link rel="prefetch" href="/assets/js/22.f0aec2af.js"><link rel="prefetch" href="/assets/js/220.18943948.js"><link rel="prefetch" href="/assets/js/221.952b0093.js"><link rel="prefetch" href="/assets/js/222.908dcde3.js"><link rel="prefetch" href="/assets/js/223.ccc9ca97.js"><link rel="prefetch" href="/assets/js/224.97bb1b38.js"><link rel="prefetch" href="/assets/js/225.f44d9991.js"><link rel="prefetch" href="/assets/js/226.0cbe1043.js"><link rel="prefetch" href="/assets/js/227.0ef2d9fa.js"><link rel="prefetch" href="/assets/js/228.08e2a12e.js"><link rel="prefetch" href="/assets/js/229.9d76c3da.js"><link rel="prefetch" href="/assets/js/23.b75f4ad8.js"><link rel="prefetch" href="/assets/js/230.0130ed60.js"><link rel="prefetch" href="/assets/js/231.cc7bfe6a.js"><link rel="prefetch" href="/assets/js/232.945b8961.js"><link rel="prefetch" href="/assets/js/233.b92a416e.js"><link rel="prefetch" href="/assets/js/234.1e603d6c.js"><link rel="prefetch" href="/assets/js/235.2cbbf26a.js"><link rel="prefetch" href="/assets/js/236.8c2d0914.js"><link rel="prefetch" href="/assets/js/237.6d37c843.js"><link rel="prefetch" href="/assets/js/238.328bfb17.js"><link rel="prefetch" href="/assets/js/239.3cfc2492.js"><link rel="prefetch" href="/assets/js/24.2f8e45fa.js"><link rel="prefetch" href="/assets/js/240.49c464d7.js"><link rel="prefetch" href="/assets/js/241.a117b6ed.js"><link rel="prefetch" href="/assets/js/242.f755edbf.js"><link rel="prefetch" href="/assets/js/243.d465b990.js"><link rel="prefetch" href="/assets/js/244.437ddc10.js"><link rel="prefetch" href="/assets/js/245.2e779b62.js"><link rel="prefetch" href="/assets/js/246.833a9e59.js"><link rel="prefetch" href="/assets/js/247.3642921c.js"><link rel="prefetch" href="/assets/js/248.6fe5d428.js"><link rel="prefetch" href="/assets/js/249.11831ea9.js"><link rel="prefetch" href="/assets/js/25.b05b892c.js"><link rel="prefetch" href="/assets/js/250.8c3ef99e.js"><link rel="prefetch" href="/assets/js/251.520e04bc.js"><link rel="prefetch" href="/assets/js/252.b091ccdc.js"><link rel="prefetch" href="/assets/js/253.b763e62c.js"><link rel="prefetch" href="/assets/js/254.4d336e26.js"><link rel="prefetch" href="/assets/js/255.5d47d641.js"><link rel="prefetch" href="/assets/js/256.baa3ebe3.js"><link rel="prefetch" href="/assets/js/257.2ffae9af.js"><link rel="prefetch" href="/assets/js/258.c604142e.js"><link rel="prefetch" href="/assets/js/259.e74e6cd6.js"><link rel="prefetch" href="/assets/js/26.8ba653c3.js"><link rel="prefetch" href="/assets/js/260.7b310562.js"><link rel="prefetch" href="/assets/js/261.e3b096df.js"><link rel="prefetch" href="/assets/js/262.808f799f.js"><link rel="prefetch" href="/assets/js/263.c560074f.js"><link rel="prefetch" href="/assets/js/264.a46a2877.js"><link rel="prefetch" href="/assets/js/265.d15875dc.js"><link rel="prefetch" href="/assets/js/266.44ad46e6.js"><link rel="prefetch" href="/assets/js/267.744591cc.js"><link rel="prefetch" href="/assets/js/268.b63a806f.js"><link rel="prefetch" href="/assets/js/269.2df63b7b.js"><link rel="prefetch" href="/assets/js/27.2649684b.js"><link rel="prefetch" href="/assets/js/270.96a1e8da.js"><link rel="prefetch" href="/assets/js/271.f7f48faf.js"><link rel="prefetch" href="/assets/js/272.89f1f9b3.js"><link rel="prefetch" href="/assets/js/273.9db895c8.js"><link rel="prefetch" href="/assets/js/28.04ba17fc.js"><link rel="prefetch" href="/assets/js/29.fc9bec6b.js"><link rel="prefetch" href="/assets/js/3.ebf0a2ca.js"><link rel="prefetch" href="/assets/js/30.8f6c8682.js"><link rel="prefetch" href="/assets/js/32.f86a299c.js"><link rel="prefetch" href="/assets/js/33.69f05cd0.js"><link rel="prefetch" href="/assets/js/34.0fcfdfd2.js"><link rel="prefetch" href="/assets/js/35.fbba2378.js"><link rel="prefetch" href="/assets/js/36.b8c83634.js"><link rel="prefetch" href="/assets/js/37.af10d35c.js"><link rel="prefetch" href="/assets/js/38.40c50958.js"><link rel="prefetch" href="/assets/js/39.048effca.js"><link rel="prefetch" href="/assets/js/4.910990f1.js"><link rel="prefetch" href="/assets/js/40.34df2e9c.js"><link rel="prefetch" href="/assets/js/41.0d92c05d.js"><link rel="prefetch" href="/assets/js/42.7d55e3eb.js"><link rel="prefetch" href="/assets/js/43.784d6526.js"><link rel="prefetch" href="/assets/js/44.ab75d220.js"><link rel="prefetch" href="/assets/js/45.1da53631.js"><link rel="prefetch" href="/assets/js/46.2bc19c98.js"><link rel="prefetch" href="/assets/js/47.ebb349e1.js"><link rel="prefetch" href="/assets/js/48.4c790e5f.js"><link rel="prefetch" href="/assets/js/49.a08ffcbf.js"><link rel="prefetch" href="/assets/js/5.1a4306f1.js"><link rel="prefetch" href="/assets/js/50.2a986267.js"><link rel="prefetch" href="/assets/js/51.b6e6ae81.js"><link rel="prefetch" href="/assets/js/52.884f6499.js"><link rel="prefetch" href="/assets/js/53.21026904.js"><link rel="prefetch" href="/assets/js/54.da32fcd7.js"><link rel="prefetch" href="/assets/js/55.8b53dfa1.js"><link rel="prefetch" href="/assets/js/56.f61d102d.js"><link rel="prefetch" href="/assets/js/57.f4da3322.js"><link rel="prefetch" href="/assets/js/58.5e3282e7.js"><link rel="prefetch" href="/assets/js/59.a84fd4f0.js"><link rel="prefetch" href="/assets/js/6.051801a8.js"><link rel="prefetch" href="/assets/js/60.5946ddf4.js"><link rel="prefetch" href="/assets/js/61.18c749ab.js"><link rel="prefetch" href="/assets/js/62.da684abf.js"><link rel="prefetch" href="/assets/js/63.2b0fa974.js"><link rel="prefetch" href="/assets/js/64.2f400a86.js"><link rel="prefetch" href="/assets/js/65.4cf2386f.js"><link rel="prefetch" href="/assets/js/66.188c4b33.js"><link rel="prefetch" href="/assets/js/67.b4f824ac.js"><link rel="prefetch" href="/assets/js/68.d77410fc.js"><link rel="prefetch" href="/assets/js/69.6e24eb76.js"><link rel="prefetch" href="/assets/js/7.8cdfab2f.js"><link rel="prefetch" href="/assets/js/70.5ca51a92.js"><link rel="prefetch" href="/assets/js/71.35d7ed60.js"><link rel="prefetch" href="/assets/js/72.a7853bf5.js"><link rel="prefetch" href="/assets/js/73.a891df77.js"><link rel="prefetch" href="/assets/js/74.e978df7f.js"><link rel="prefetch" href="/assets/js/75.ab5a4524.js"><link rel="prefetch" href="/assets/js/76.ea1c6d79.js"><link rel="prefetch" href="/assets/js/77.711c0174.js"><link rel="prefetch" href="/assets/js/78.35dd5c6c.js"><link rel="prefetch" href="/assets/js/79.d7524830.js"><link rel="prefetch" href="/assets/js/8.badb7759.js"><link rel="prefetch" href="/assets/js/80.7e16490b.js"><link rel="prefetch" href="/assets/js/81.15f00868.js"><link rel="prefetch" href="/assets/js/82.0fe7b576.js"><link rel="prefetch" href="/assets/js/83.fc62b16f.js"><link rel="prefetch" href="/assets/js/84.2a4f555c.js"><link rel="prefetch" href="/assets/js/85.edffb2ef.js"><link rel="prefetch" href="/assets/js/86.69991118.js"><link rel="prefetch" href="/assets/js/87.621cee7a.js"><link rel="prefetch" href="/assets/js/88.5507cc10.js"><link rel="prefetch" href="/assets/js/89.5d34d988.js"><link rel="prefetch" href="/assets/js/9.d4fc76e7.js"><link rel="prefetch" href="/assets/js/90.cc841762.js"><link rel="prefetch" href="/assets/js/91.a24381d0.js"><link rel="prefetch" href="/assets/js/92.cbd5d458.js"><link rel="prefetch" href="/assets/js/93.530432c0.js"><link rel="prefetch" href="/assets/js/94.0524cfdd.js"><link rel="prefetch" href="/assets/js/95.0214ae22.js"><link rel="prefetch" href="/assets/js/96.7942792a.js"><link rel="prefetch" href="/assets/js/97.35d91de8.js"><link rel="prefetch" href="/assets/js/98.eafbdc44.js"><link rel="prefetch" href="/assets/js/99.db414aab.js">
    <link rel="stylesheet" href="/assets/css/0.styles.18a91880.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Gpingの知识库" class="logo"> <span class="site-name can-hide">Gpingの知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/2dbd58/" class="nav-link">📚小手册</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="📖基础" class="dropdown-title"><!----> <span class="title" style="display:;">📖基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/27f9fa/" class="nav-link">Java8新特性</a></li><li class="dropdown-item"><!----> <a href="/pages/96d5aa/" class="nav-link">Java并发编程</a></li><li class="dropdown-item"><!----> <a href="/pages/00e30d/" class="nav-link">Java虚拟机</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🏷️框架" class="dropdown-title"><!----> <span class="title" style="display:;">🏷️框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/bb39d9/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/pages/24c3ee/" class="nav-link">SpringSecurity</a></li><li class="dropdown-item"><!----> <a href="/pages/1ab42b/" class="nav-link">ThingsBoard</a></li><li class="dropdown-item"><!----> <a href="/pages/fb96c3/" class="nav-link">Jpa</a></li><li class="dropdown-item"><!----> <a href="/pages/34b19f/" class="nav-link">Activiti7</a></li><li class="dropdown-item"><!----> <a href="/pages/d33c62/" class="nav-link">Quartz</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⚔️中间件" class="dropdown-title"><!----> <span class="title" style="display:;">⚔️中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/c4d661/" class="nav-link">Rabbitmq</a></li><li class="dropdown-item"><!----> <a href="/pages/fe0a41/" class="nav-link">Kafka</a></li><li class="dropdown-item"><!----> <a href="/pages/eeddc3/" class="nav-link">Canal</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="📁数据库" class="dropdown-title"><!----> <span class="title" style="display:;">📁数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/0ef684/" class="nav-link">Mysql</a></li><li class="dropdown-item"><!----> <a href="/pages/a174cd/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/pages/4cfb74/" class="nav-link">InfluxDB</a></li><li class="dropdown-item"><!----> <a href="/pages/9c8057/" class="nav-link">ClickHouse</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧰实用工具" class="dropdown-title"><!----> <span class="title" style="display:;">🧰实用工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/32a577/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/9864be/" class="nav-link">Maven</a></li><li class="dropdown-item"><!----> <a href="/pages/f5b30e/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/pages/290042/" class="nav-link">Arthas</a></li><li class="dropdown-item"><!----> <a href="/pages/9eb455/" class="nav-link">Idea</a></li><li class="dropdown-item"><!----> <a href="/pages/151c97/" class="nav-link">开发工具</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🐞运维" class="dropdown-title"><!----> <span class="title" style="display:;">🐞运维</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/748b9f/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/pages/4b6fee/" class="nav-link">Linux</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="💡其他" class="dropdown-title"><!----> <span class="title" style="display:;">💡其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9cc0e1/" class="nav-link">高项</a></li><li class="dropdown-item"><!----> <a href="/pages/10e161/" class="nav-link">不一样的树形构建方式</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/2dbd58/" class="nav-link">📚小手册</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="📖基础" class="dropdown-title"><!----> <span class="title" style="display:;">📖基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/27f9fa/" class="nav-link">Java8新特性</a></li><li class="dropdown-item"><!----> <a href="/pages/96d5aa/" class="nav-link">Java并发编程</a></li><li class="dropdown-item"><!----> <a href="/pages/00e30d/" class="nav-link">Java虚拟机</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🏷️框架" class="dropdown-title"><!----> <span class="title" style="display:;">🏷️框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/bb39d9/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/pages/24c3ee/" class="nav-link">SpringSecurity</a></li><li class="dropdown-item"><!----> <a href="/pages/1ab42b/" class="nav-link">ThingsBoard</a></li><li class="dropdown-item"><!----> <a href="/pages/fb96c3/" class="nav-link">Jpa</a></li><li class="dropdown-item"><!----> <a href="/pages/34b19f/" class="nav-link">Activiti7</a></li><li class="dropdown-item"><!----> <a href="/pages/d33c62/" class="nav-link">Quartz</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⚔️中间件" class="dropdown-title"><!----> <span class="title" style="display:;">⚔️中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/c4d661/" class="nav-link">Rabbitmq</a></li><li class="dropdown-item"><!----> <a href="/pages/fe0a41/" class="nav-link">Kafka</a></li><li class="dropdown-item"><!----> <a href="/pages/eeddc3/" class="nav-link">Canal</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="📁数据库" class="dropdown-title"><!----> <span class="title" style="display:;">📁数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/0ef684/" class="nav-link">Mysql</a></li><li class="dropdown-item"><!----> <a href="/pages/a174cd/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/pages/4cfb74/" class="nav-link">InfluxDB</a></li><li class="dropdown-item"><!----> <a href="/pages/9c8057/" class="nav-link">ClickHouse</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧰实用工具" class="dropdown-title"><!----> <span class="title" style="display:;">🧰实用工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/32a577/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/9864be/" class="nav-link">Maven</a></li><li class="dropdown-item"><!----> <a href="/pages/f5b30e/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/pages/290042/" class="nav-link">Arthas</a></li><li class="dropdown-item"><!----> <a href="/pages/9eb455/" class="nav-link">Idea</a></li><li class="dropdown-item"><!----> <a href="/pages/151c97/" class="nav-link">开发工具</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🐞运维" class="dropdown-title"><!----> <span class="title" style="display:;">🐞运维</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/748b9f/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/pages/4b6fee/" class="nav-link">Linux</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="💡其他" class="dropdown-title"><!----> <span class="title" style="display:;">💡其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9cc0e1/" class="nav-link">高项</a></li><li class="dropdown-item"><!----> <a href="/pages/10e161/" class="nav-link">不一样的树形构建方式</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JVM</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>内存与垃圾回收篇</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/00e30d/" class="sidebar-link">JVM与Java体系结构</a></li><li><a href="/pages/2a2043/" class="sidebar-link">类加载子系统</a></li><li><a href="/pages/2898db/" class="sidebar-link">运行时数据区</a></li><li><a href="/pages/24f838/" class="sidebar-link">程序计数器（PC寄存器）</a></li><li><a href="/pages/27bd58/" class="sidebar-link">虚拟机栈</a></li><li><a href="/pages/59ab02/" class="sidebar-link">本地方法栈和本地方法接口</a></li><li><a href="/pages/1553ef/" class="sidebar-link">Java堆</a></li><li><a href="/pages/5703a7/" class="sidebar-link">方法区</a></li><li><a href="/pages/ac9d50/" class="sidebar-link">对象实例化及直接内存</a></li><li><a href="/pages/4f7794/" class="sidebar-link">执行引擎</a></li><li><a href="/pages/af351d/" class="sidebar-link">String Table</a></li><li><a href="/pages/7fecdf/" class="sidebar-link">垃圾收集概述</a></li><li><a href="/pages/64d576/" class="sidebar-link">垃圾收集算法</a></li><li><a href="/pages/9777ac/" class="sidebar-link">垃圾收集相关概念</a></li><li><a href="/pages/f50a3c/" aria-current="page" class="active sidebar-link">垃圾收集器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/f50a3c/#垃圾收集器" class="sidebar-link">垃圾收集器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#gc性能指标" class="sidebar-link">GC性能指标</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#吞吐量" class="sidebar-link">吞吐量</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#暂停时间" class="sidebar-link">暂停时间</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#吞吐量-vs-暂停时间" class="sidebar-link">吞吐量 vs 暂停时间</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#垃圾收集器分类" class="sidebar-link">垃圾收集器分类</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#按线程数分" class="sidebar-link">按线程数分</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#按照工作模式分" class="sidebar-link">按照工作模式分</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#按碎片处理方式分" class="sidebar-link">按碎片处理方式分</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#按工作的内存区间分" class="sidebar-link">按工作的内存区间分</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#不同的垃圾回收器概述" class="sidebar-link">不同的垃圾回收器概述</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#垃圾回收器发展史" class="sidebar-link">垃圾回收器发展史</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#_7种经典的垃圾收集器" class="sidebar-link">7种经典的垃圾收集器</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#_7款经典收集器与垃圾分代之间的关系" class="sidebar-link">7款经典收集器与垃圾分代之间的关系</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#垃圾收集器的组合关系" class="sidebar-link">垃圾收集器的组合关系</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#不同的垃圾收集器概述" class="sidebar-link">不同的垃圾收集器概述</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#如何查看默认垃圾收集器" class="sidebar-link">如何查看默认垃圾收集器</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#serial回收器-串行回收" class="sidebar-link">Serial回收器：串行回收</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#优势" class="sidebar-link">优势</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#应用场景" class="sidebar-link">应用场景</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#parnew回收器-并行回收" class="sidebar-link">ParNew回收器：并行回收</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#概述-2" class="sidebar-link">概述</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#工作原理" class="sidebar-link">工作原理</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#如何设置使用parnew垃圾回收器" class="sidebar-link">如何设置使用ParNew垃圾回收器</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#parallel回收器-吞吐量优先" class="sidebar-link">Parallel回收器：吞吐量优先</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#概述-3" class="sidebar-link">概述</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#工作原理-2" class="sidebar-link">工作原理</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#相关参数配置" class="sidebar-link">相关参数配置</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#cms回收器-低延迟" class="sidebar-link">CMS回收器：低延迟</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#概述-4" class="sidebar-link">概述</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#工作原理-3" class="sidebar-link">工作原理</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#初始标记阶段" class="sidebar-link">初始标记阶段</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#并发标记阶段" class="sidebar-link">并发标记阶段</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#重新标记阶段" class="sidebar-link">重新标记阶段</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#并发清除阶段" class="sidebar-link">并发清除阶段</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#弊端" class="sidebar-link">弊端</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#参数设置" class="sidebar-link">参数设置</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#jdk后续版本中cms的变化" class="sidebar-link">JDK后续版本中CMS的变化</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#g1回收器-区域化分代式" class="sidebar-link">G1回收器：区域化分代式</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#g1概述" class="sidebar-link">G1概述</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#g1发展历程" class="sidebar-link">G1发展历程</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#为什么叫g1" class="sidebar-link">为什么叫G1</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#g1回收器的特点" class="sidebar-link">G1回收器的特点</a></li><li class="sidebar-sub-header level5"><a href="/pages/f50a3c/#并行与并发" class="sidebar-link">并行与并发</a></li><li class="sidebar-sub-header level5"><a href="/pages/f50a3c/#分代收集" class="sidebar-link">分代收集</a></li><li class="sidebar-sub-header level5"><a href="/pages/f50a3c/#空间整合" class="sidebar-link">空间整合</a></li><li class="sidebar-sub-header level5"><a href="/pages/f50a3c/#可预测的停顿时间模型" class="sidebar-link">可预测的停顿时间模型</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#g1回收器的缺点" class="sidebar-link">G1回收器的缺点</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#g1回收器的参数设置" class="sidebar-link">G1回收器的参数设置</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#g1收集器的常见操作步骤" class="sidebar-link">G1收集器的常见操作步骤</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#分区region-化整为零" class="sidebar-link">分区Region-化整为零</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#跨region引用对象问题" class="sidebar-link">跨Region引用对象问题？</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#g1垃圾回收器的回收过程" class="sidebar-link">G1垃圾回收器的回收过程</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#垃圾回收器总结" class="sidebar-link">垃圾回收器总结</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#gc日志分析" class="sidebar-link">GC日志分析</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#minor-gc日志" class="sidebar-link">Minor GC日志</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#full-gc日志" class="sidebar-link">Full GC日志</a></li><li class="sidebar-sub-header level3"><a href="/pages/f50a3c/#垃圾回收器的新发展" class="sidebar-link">垃圾回收器的新发展</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#jdk11新特性" class="sidebar-link">JDK11新特性</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#open-jdk12的shenandoash-gc" class="sidebar-link">Open JDK12的Shenandoash GC</a></li><li class="sidebar-sub-header level4"><a href="/pages/f50a3c/#令人震惊、革命性的zgc" class="sidebar-link">令人震惊、革命性的ZGC</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>字节码与类的加载篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>性能监控与调优篇</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>JVM</span></li><li data-v-06225672><span data-v-06225672>JVM</span></li><li data-v-06225672><span data-v-06225672>内存与垃圾回收篇</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="javascript:;" data-v-06225672>gping</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-10-22</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">垃圾收集器<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="垃圾收集器"><a href="#垃圾收集器" class="header-anchor">#</a> 垃圾收集器</h2> <h3 id="gc性能指标"><a href="#gc性能指标" class="header-anchor">#</a> <strong>GC性能指标</strong></h3> <ul><li>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li></ul> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230821170004741.png" alt="image-20230821170004741"></p> <ul><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li></ul> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230821170433178.png" alt="image-20230821170433178"></p> <ul><li><p>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</p></li> <li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p></li> <li><p>内存占用：Java堆区所占的内存大小。</p></li> <li><p>快速：一个对象从诞生到被回收所经历的时间。</p></li></ul> <p>吞吐量、暂停时间、内存占用 这三者共同构成一个<code>不可能三角</code>。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p> <p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p> <p>简单来说，主要抓住两点：<code>吞吐量</code>、<code>暂停时间</code></p> <h4 id="吞吐量"><a href="#吞吐量" class="header-anchor">#</a> <strong>吞吐量</strong></h4> <blockquote><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。它表示在一段时间内，CPU有多少时间是用于执行实际的用户代码，而不是用于执行垃圾回收操作。具体计算公式为：吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。</p></blockquote> <p>假设虚拟机总共运行了100分钟，其中垃圾收集花费了1分钟，那么根据吞吐量的计算公式，吞吐量为 99%。这表示在整个运行过程中，有99%的时间是用于执行用户代码，只有1%的时间用于执行垃圾收集操作。</p> <p>在高吞吐量优先的情况下，应用程序需要容忍较高的暂停时间，意味着<code>在单位时间内，STW的时间最短</code>。应用程序会<code>尽量减少 STW 时间</code>，以便在单位时间内<code>最大程度地执行用户代码</code>。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token number">200</span>ms <span class="token operator">+</span> <span class="token number">200</span>ms <span class="token operator">=</span> <span class="token number">400</span>ms <span class="token operator">=</span> <span class="token number">0.4</span>s
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230821171935622.png" alt="image-20230821171935622"></p> <h4 id="暂停时间"><a href="#暂停时间" class="header-anchor">#</a> <strong>暂停时间</strong></h4> <blockquote><p>暂停时间指的是应用程序线程在某个时间段内被暂停，以便垃圾收集（GC）线程可以执行。在这段暂停时间内，应用程序线程处于不活动状态，而GC线程在进行垃圾回收操作。</p></blockquote> <p>假设在一个时间段内，有五次垃圾收集，每次垃圾收集引起的暂停时间分别是0.1秒。这意味着在每次垃圾收集时，应用程序线程会停止运行，垃圾收集线程执行垃圾回收操作。将这五次暂停时间相加，总暂停时间为0.5秒。这是这段时间内应用程序线程停止执行的总时间。</p> <p>当强调<code>暂停时间优先</code>时，意味着关注将每次停止应用程序线程的时间（STW时间）尽量缩短。以便应用程序线程尽快恢复活动状态。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token number">100</span>ms <span class="token operator">+</span> <span class="token number">100</span>ms <span class="token operator">+</span> <span class="token number">100</span>ms <span class="token operator">+</span> <span class="token number">100</span>ms <span class="token operator">+</span> <span class="token number">100</span>ms <span class="token operator">=</span> <span class="token number">500</span>ms <span class="token operator">=</span> <span class="token number">0.5</span>s
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230821173446972.png" alt="image-20230821173446972"></p> <h4 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="header-anchor">#</a> <strong>吞吐量 vs 暂停时间</strong></h4> <p><strong>高吞吐量优势：</strong> 高吞吐量意味着应用程序能够在单位时间内处理更多的工作，使用户感觉应用程序一直在<code>生产性</code>工作，从而快速执行。这在某些场景下非常有利，用户会感觉应用程序的响应速度很快。</p> <p><strong>低暂停时间优势：</strong> 低暂停时间或低延迟意味着应用程序的暂停时间较短，从最终用户的角度来看，无论是由于垃圾收集还是其他原因，应用程序挂起的时间都较短。在交互式应用程序等实时性要求较高的情况下，较低的暂停时间对于保持用户体验至关重要。</p> <p><strong>竞争关系：</strong> 高吞吐量和低暂停时间之间存在竞争关系。<code>提高吞吐量通常需要降低内存回收的频率</code>，这会<code>导致较长的垃圾收集暂停</code>。反之，为了<code>降低暂停时间</code>，可能需要<code>更频繁地执行内存回收</code>，但这可能<code>降低吞吐量</code>。</p> <p><strong>折衷方案：</strong> 在设计或使用垃圾收集算法时，通常需要在<code>高吞吐量</code>和<code>低暂停时间</code>之间做出折衷。现代的垃圾收集器通常尝试找到这两者之间的平衡，以提供在不同场景下都能够满足性能需求的解决方案。</p> <p>**现在标准：**在最大吞吐量优先的情况下，降低暂停时间。</p> <h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="header-anchor">#</a> 垃圾收集器分类</h3> <h4 id="按线程数分"><a href="#按线程数分" class="header-anchor">#</a> 按线程数分</h4> <p>可以分为<code>串行垃圾回收器</code>和<code>并行垃圾回收器</code>。</p> <table><thead><tr><th>分类</th> <th>收集器</th></tr></thead> <tbody><tr><td>串行</td> <td>Serial收集器</td></tr> <tr><td></td> <td>Serial Old收集器</td></tr> <tr><td>并行</td> <td>ParNew收集器</td></tr> <tr><td></td> <td>Parallel Scavenge收集器</td></tr> <tr><td></td> <td>Parallel Old收集器</td></tr></tbody></table> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/QQ%E6%88%AA%E5%9B%BE20230821163012.png" alt="QQ截图20230821163012"></p> <p><strong>串行回收</strong></p> <blockquote><p>串行回收不仅仅指的是在同一时间段内只<code>允许有一个CPU</code>或<code>一条收集线程</code>用于执行垃圾回收操作。更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p></blockquote> <p><strong>并行回收</strong></p> <blockquote><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了<code>Stop-the-World</code>机制。</p></blockquote> <h4 id="按照工作模式分"><a href="#按照工作模式分" class="header-anchor">#</a> 按照工作模式分</h4> <p>可以分为<code>并发式垃圾回收器</code>和<code>独占式垃圾回收器</code>。</p> <table><thead><tr><th>类型</th> <th>垃圾回收器</th></tr></thead> <tbody><tr><td>并发式垃圾回收</td> <td>CMS（Concurrent Mark-Sweep）</td></tr> <tr><td></td> <td>G1（Garbage-First）</td></tr> <tr><td>独占式垃圾回收</td> <td>Serial收集器</td></tr> <tr><td></td> <td>Parallel Scavenge收集器</td></tr> <tr><td></td> <td>Serial Old收集器</td></tr></tbody></table> <p><strong>并发式垃圾回收</strong></p> <blockquote><p>这些垃圾收集器在执行垃圾回收时，与应用程序的线程交替运行。</p></blockquote> <p><strong>独占式垃圾回收</strong></p> <blockquote><p>独占式垃圾回收器（Stop the world）一旦运行，就<code>停止应用程序中的所有用户线程</code>，直到垃圾回收过程完全结束</p></blockquote> <h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="header-anchor">#</a> 按碎片处理方式分</h4> <p>可分为<code>压缩式垃圾回收器</code>和<code>非压缩式垃圾回收器</code>。</p> <table><thead><tr><th>类型</th> <th>垃圾回收器</th></tr></thead> <tbody><tr><td>压缩式垃圾回收</td> <td>G1（Garbage-First）</td></tr> <tr><td></td> <td>ZGC 收集器</td></tr> <tr><td>非压缩式垃圾回收</td> <td>Serial收集器</td></tr> <tr><td></td> <td>Parallel Scavenge收集器</td></tr> <tr><td></td> <td>Serial Old收集器</td></tr> <tr><td></td> <td>CMS（Concurrent Mark-Sweep）</td></tr></tbody></table> <p><strong>压缩式垃圾回收</strong></p> <blockquote><p>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片</p></blockquote> <p><strong>非压缩式垃圾回收</strong></p> <blockquote><p>非压缩式的垃圾回收器在回收完成后，不进行压缩整理</p></blockquote> <h4 id="按工作的内存区间分"><a href="#按工作的内存区间分" class="header-anchor">#</a> 按工作的内存区间分</h4> <p>又可分为<code>年轻代垃圾回收器</code>和<code>老年代垃圾回收器</code>。</p> <table><thead><tr><th>型</th> <th>垃圾回收器</th></tr></thead> <tbody><tr><td>年轻代垃圾回收</td> <td>Serial收集器</td></tr> <tr><td></td> <td>ParNew收集器</td></tr> <tr><td></td> <td>Parallel Scavenge收集器</td></tr> <tr><td>老年代垃圾回收</td> <td>Serial Old收集器</td></tr> <tr><td></td> <td>Parallel Old收集器</td></tr> <tr><td></td> <td>CMS（Concurrent Mark-Sweep）</td></tr> <tr><td>整堆垃圾回收</td> <td>G1（Garbage-First）</td></tr></tbody></table> <h3 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="header-anchor">#</a> 不同的垃圾回收器概述</h3> <h4 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="header-anchor">#</a> 垃圾回收器发展史</h4> <ul><li><p>1999年随JDK1.3.1一起来的是串行方式的<code>Serial GC</code>，它是第一款GC。<code>ParNew GC</code>是Serial收集器的多线程版本</p></li> <li><p>2002年2月26日，<code>Parallel GC</code>和<code>Concurrent Mark Sweep GC(简称CMS)</code>跟随JDK1.4.2一起发布</p></li> <li><p><code>Parallel GC</code>在JDK6之后成为<code>HotSpot默认GC</code>。</p></li> <li><p>2012年，在JDK1.7u4版本中，<code>G1</code>可用。</p></li> <li><p>2017年，JDK9中<code>G1变成默认的垃圾收集器</code>，以替代<code>CMS</code>。</p></li> <li><p>2018年3月，JDK10中<code>G1垃圾回收器</code>的<code>并行完整垃圾回收</code>，实现并行性来改善最坏情况下的延迟。</p></li> <li><p>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 &quot;No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）。</p></li> <li><p>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</p></li> <li><p>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</p></li> <li><p>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macos和Windows上的应用</p></li></ul> <h4 id="_7种经典的垃圾收集器"><a href="#_7种经典的垃圾收集器" class="header-anchor">#</a> 7种经典的垃圾收集器</h4> <p>官方手册：https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</p> <table><thead><tr><th>类型</th> <th>垃圾回收器</th></tr></thead> <tbody><tr><td>串行回收器</td> <td>Serial</td></tr> <tr><td></td> <td>Serial Old</td></tr> <tr><td></td> <td></td></tr> <tr><td>并行回收器</td> <td>ParNew</td></tr> <tr><td></td> <td>Parallel Scavenge</td></tr> <tr><td></td> <td>Parallel Old</td></tr> <tr><td></td> <td></td></tr> <tr><td>并发回收器</td> <td>CMS（Concurrent Mark-Sweep）</td></tr> <tr><td></td> <td>G1（Garbage-First）</td></tr></tbody></table> <h4 id="_7款经典收集器与垃圾分代之间的关系"><a href="#_7款经典收集器与垃圾分代之间的关系" class="header-anchor">#</a> 7款经典收集器与垃圾分代之间的关系</h4> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/69f86041-810a-4133-abbe-3ab62fa069a3.png" alt="69f86041-810a-4133-abbe-3ab62fa069a3"></p> <table><thead><tr><th>堆区</th> <th>垃圾回收器</th></tr></thead> <tbody><tr><td>新生代</td> <td>Serial</td></tr> <tr><td></td> <td>ParNew</td></tr> <tr><td></td> <td>Parallel Scavenge</td></tr> <tr><td></td> <td></td></tr> <tr><td>老年代</td> <td>Serial Old</td></tr> <tr><td></td> <td>Parallel Old</td></tr> <tr><td></td> <td>CMS（Concurrent Mark-Sweep）</td></tr> <tr><td></td> <td></td></tr> <tr><td>整堆</td> <td>G1（Garbage-First）</td></tr></tbody></table> <h4 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="header-anchor">#</a> 垃圾收集器的组合关系</h4> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/58edbeca-d4e6-4a60-aad7-d320927b126f.png" alt="58edbeca-d4e6-4a60-aad7-d320927b126f"></p> <p>1、两个收集器间有连线，表明它们可以搭配使用：<code>Serial/Serial Old</code>、<code>Serial/CMS</code>、<code>ParNew/Serial Old</code>、<code>ParNew/CMS</code>、<code>Parallel Scavenge/Serial Old</code>、<code>Parallel Scavenge/Parallel Old</code>、<code>G1</code>。</p> <p>2、其中<code>Serial Old</code>作为<code>CMS</code>出现<code>Concurrent Mode Failure</code>失败的后备预案。</p> <p>3、（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将<code>Serial+CMS</code>、<code>ParNew+Serial Old</code>这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</p> <p>4、（绿色虚线）JDK14中：弃用<code>Parallel Scavenge</code>和<code>Serialold GC</code>组合（JEP366）。</p> <p>5、（浅蓝色虚框）JDK14中：删除<code>CMS</code>垃圾回收器（JEP363）。</p> <h4 id="不同的垃圾收集器概述"><a href="#不同的垃圾收集器概述" class="header-anchor">#</a> 不同的垃圾收集器概述</h4> <p>为什么要有很多收集器，一个不够吗？因为不同的使用场景和需求导致了多样性的应用需求。这多样性体现在移动端、服务器等不同环境中。因此，为了优化垃圾收集性能，针对不同的应用场景提供不同的垃圾收集器是必要的。</p> <p>虽然我们会对不同的垃圾收集器进行比较，但目的并不是挑选出一个绝对最好的收集器。没有一种通用、适用于所有场景的完美收集器存在，更没有一种万能的解决方案。因此，<code>我们所做的是选择对特定应用最为合适的收集器</code>，以满足不同环境下的性能和需求。</p> <h4 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="header-anchor">#</a> 如何查看默认垃圾收集器</h4> <p>1、<code>-XX:+PrintCommandLineFlags</code> 参数用于在启动 Java 虚拟机时打印命令行标志，其中包括 JVM 使用的各种参数，包括所选用的垃圾收集器。</p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230822105122128.png" alt="image-20230822105122128"></p> <p><strong>输出以下内容：</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">InitialHeapSize</span><span class="token operator">=</span><span class="token number">264449728</span> 
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxHeapSize</span><span class="token operator">=</span><span class="token number">4231195648</span> 
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintCommandLineFlags</span> 
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseCompressedClassPointers</span> 
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseCompressedOops</span> 
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">-</span><span class="token class-name">UseLargePagesIndividualAllocation</span> 
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseParallelGC</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><code>-XX:InitialHeapSize=264449728</code>：设置初始堆大小为 264449728 字节（约 252 MB）。这是 Java 堆的初始大小，堆是用于存储对象实例的内存区域。</li> <li><code>-XX:MaxHeapSize=4231195648</code>：设置最大堆大小为 4231195648 字节（约 4033 MB）。这是 Java 堆的最大大小，它是堆内存的上限。</li> <li><code>-XX:+PrintCommandLineFlags</code>：这个参数会在启动时打印出 Java 虚拟机的命令行标志，包括所有传递给虚拟机的参数。</li> <li><code>-XX:+UseCompressedClassPointers</code>：启用压缩的类指针。这个选项允许 JVM 使用更小的指针来表示类的元数据，从而减少堆内存的消耗。</li> <li><code>-XX:+UseCompressedOops</code>：启用压缩的普通对象指针。类似于上一个参数，这个选项允许 JVM 使用更小的指针来表示普通对象的引用，以降低堆内存的使用。</li> <li><code>-XX:-UseLargePagesIndividualAllocation</code>：禁用大页面分配。大页面是一种内存分配策略，但在某些情况下可能导致性能问题，此选项将其禁用。</li> <li><code>-XX:+UseParallelGC</code>：使用并行垃圾收集器。这个选项指示 JVM 使用并行收集器，它会在多个线程上并行执行垃圾回收操作，以提高吞吐量。</li></ul> <p>2、使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>先使用<code>jps</code>命令查看对应的进程ID</p></div> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// UseParallelGC 是并行收集器的一个参数</span>
jinfo <span class="token operator">-</span>flag <span class="token class-name">UseParallelGC</span> 进程<span class="token constant">ID</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230822104934947.png" alt="image-20230822104934947"></p> <h3 id="serial回收器-串行回收"><a href="#serial回收器-串行回收" class="header-anchor">#</a> Serial回收器：串行回收</h3> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <blockquote><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p></blockquote> <p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p> <p>Serial收集器采用<code>复制算法</code>、<code>串行回收</code>和<code>stop-the-World</code>机制的方式执行内存回收。</p> <p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。<code>Serial Old收集器同样也采用了串行回收和&quot;Stop the World&quot;机制，只不过内存回收算法使用的是标记-压缩算法。</code></p> <ul><li><p><code>Serial old</code>是运行在Client模式下默认的<code>老年代</code>的垃圾回收器。</p></li> <li><p><code>Serial 0ld</code>在Server模式下主要有两个用途：</p> <ul><li>与新生代的Parallel scavenge配合使用</li> <li>作为老年代CMS收集器的后备垃圾收集方案</li></ul></li></ul> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230822113014336.png" alt="image-20230822113014336"></p> <p>这个收集器是一个单线程的收集器，但它的<code>单线程</code>的意义并不仅仅说明它只会<code>使用一个CPU或一条收集线程去完成垃圾收集工作</code>，更重要的是在它进行垃圾收集时，<code>必须暂停其他所有的工作线程</code>，直到它收集结束（Stop The World）。</p> <h4 id="优势"><a href="#优势" class="header-anchor">#</a> 优势</h4> <p><code>简单而高效</code>（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。</p> <h4 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h4> <p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p> <p>在HotSpot虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC，且老年代用Serial Old GC。</p> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> <strong>总结</strong></h4> <p>这种垃圾收集器我们只需要了解即可，因为现在已经不用串行了。而且在限定单核cpu才可以用。现在的电脑或者服务器很多都是多核。</p> <p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p> <h3 id="parnew回收器-并行回收"><a href="#parnew回收器-并行回收" class="header-anchor">#</a> ParNew回收器：并行回收</h3> <h4 id="概述-2"><a href="#概述-2" class="header-anchor">#</a> 概述</h4> <p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的<code>多线程版本</code>。</p> <ul><li><code>Par</code>：是Parallel的缩写</li> <li><code>New</code>：只能处理的是新生代</li></ul> <p>ParNew 收集器除了采用<code>并行回收</code>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用<code>复制算法</code>、<code>Stop-the-World</code>机制。</p> <p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p> <ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li> <li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul> <h4 id="工作原理"><a href="#工作原理" class="header-anchor">#</a> 工作原理</h4> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230822115213672.png" alt="image-20230822115213672"></p> <p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效❓</p> <ul><li><p>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</p></li> <li><p>但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</p></li></ul> <p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作。</p> <p>在程序中，开发人员可以通过选项<code>-XX:+/-UseParNewGC</code>手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p> <p>可以使用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数，默认开启和CPU数据相同的线程数。</p> <h4 id="如何设置使用parnew垃圾回收器"><a href="#如何设置使用parnew垃圾回收器" class="header-anchor">#</a> 如何设置使用ParNew垃圾回收器</h4> <p><strong>代码</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * @author:wgp
 * @create: 2023-08-26 10:48
 * @Description: -XX:+PrintCommandLineFlags -XX:+UseParNewGC
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GcUseTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>在jdk8中使用ParNew</strong></p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230826111231708.png" alt="image-20230826111231708"></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Java</span> <span class="token class-name">HotSpot</span><span class="token punctuation">(</span><span class="token constant">TM</span><span class="token punctuation">)</span> <span class="token number">64</span><span class="token operator">-</span><span class="token class-name">Bit</span> <span class="token class-name">Server</span> <span class="token constant">VM</span> warning<span class="token operator">:</span> <span class="token class-name">Using</span> the <span class="token class-name">ParNew</span> young collector <span class="token keyword">with</span> <span class="token namespace">the</span> <span class="token class-name">Serial</span> old collector is deprecated and will likely be removed in a future release
    
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">InitialHeapSize</span><span class="token operator">=</span><span class="token number">264449728</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxHeapSize</span><span class="token operator">=</span><span class="token number">4231195648</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintCommandLineFlags</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseCompressedClassPointers</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseCompressedOops</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">-</span><span class="token class-name">UseLargePagesIndividualAllocation</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseParNewGC</span> 

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Java HotSpot（TM）64位服务器虚拟机警告：不赞成将ParNew年轻收集器与Serial旧收集器一起使用，可能会在将来的版本中删除</p> <p><strong>在jdk9中使用ParNew</strong></p> <p><img src="C:%5CUsers%5Ccgkj0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230826111020830.png" alt="image-20230826111020830"></p> <p>Java HotSpot（TM）64位服务器虚拟机警告：选项UseParNewGC在9.0版本中已弃用，可能会在将来的版本中删除。</p> <p>不可能将ParNew年轻收集器与CMS以外的任何收集器相结合。</p> <h3 id="parallel回收器-吞吐量优先"><a href="#parallel回收器-吞吐量优先" class="header-anchor">#</a> Parallel回收器：吞吐量优先</h3> <h4 id="概述-3"><a href="#概述-3" class="header-anchor">#</a> 概述</h4> <blockquote><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了<code>复制算法</code>、<code>并行回收</code>和<code>Stop the World</code>机制。</p></blockquote> <p>那Parallel Scavenge有什么特别之处呢❓</p> <ul><li><p>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个<code>可控制的吞吐量</code>（Throughput），它也被称为吞吐量优先的垃圾收集器。</p></li> <li><p>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</p></li></ul> <p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要<code>适合在后台运算而不需要太多交互的任务</code>。因此，常见在服务器环境中使用。例如，那些执行<code>批量处理</code>、<code>订单处理</code>、<code>工资支付</code>、<code>科学计算</code>的应用程序。</p> <p><code>Parallel</code> 收集器在JDK1.6时提供了用于执行老年代垃圾收集的<code>Parallel Old</code>收集器，用来代替老年代的<code>Serial Old</code>收集器。</p> <p><code>Parallel Old</code>收集器采用了<code>标记-压缩算法</code>，但同样也是基于<code>并行回收</code>和<code>Stop-the-World</code>机制。</p> <h4 id="工作原理-2"><a href="#工作原理-2" class="header-anchor">#</a> 工作原理</h4> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230822121418176.png" alt="image-20230822121418176"></p> <p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p> <h4 id="相关参数配置"><a href="#相关参数配置" class="header-anchor">#</a> <strong>相关参数配置</strong></h4> <ul><li><p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p></li> <li><p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。</p> <ul><li>分别适用于新生代和老年代。<code>默认JDK8是开启的</code>。</li> <li>上面两个参数，默认开启一个，另一个也会被开启。<code>（互相激活）</code></li></ul></li> <li><p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230822121035461.png" alt="image-20230822121035461"></p></li> <li><p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。 ⛔️该参数使用需谨慎。</p> <ul><li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li> <li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li></ul></li> <li><p><code>-XX:GCTimeRatio</code> 用于设置垃圾回收时间与应用程序执行时间的比率。（1 / （1+N）），<code>GCTimeRatio</code>设置的是N的值。</p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230821170433178.png" alt="image-20230821170433178"></p> <ul><li>例如，将-XX:GCTimeRatio设置为19，意味着允许的最大垃圾收集时间占总时间的比率为1/(1+19)，即约5%。这意味着在每个总时间段内，垃圾收集时间最多占总时间的5%。换句话说，应用程序执行时间将占总时间的95%。</li> <li>N取值范围（0, 100）。默认情况下，-XX:GCTimeRatio的值为99，即允许的最大垃圾收集时间占总时间的比率为1/(1+99)，即约1%。这意味着在每个总时间段内，垃圾收集时间最多占总时间的1%。应用程序执行时间将占总时间的99%。</li> <li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</li></ul></li> <li><p><code>-XX:+UseAdaptivesizePolicy</code> 设置Parallel Scavenge收集器具有<code>自适应调节策略</code></p> <ul><li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li> <li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li></ul></li></ul> <h3 id="cms回收器-低延迟"><a href="#cms回收器-低延迟" class="header-anchor">#</a> CMS回收器：低延迟</h3> <h4 id="概述-4"><a href="#概述-4" class="header-anchor">#</a> 概述</h4> <p>在JDK1.5时期，Hotspot推出了一款在<code>强交互应用</code>中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<code>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</code></p> <p>CMS收集器的关注点是<code>尽可能缩短垃圾收集时用户线程的停顿时间</code>。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p> <ul><li><code>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</code>CMS收集器就非常符合这类应用的需求。</li> <li>CMS的垃圾收集算法采用<code>标记-清除算法</code>，并且也会<code>Stop-the-World</code>。</li></ul> <p>💔不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，原因是这两者的底层框架是不一样的。所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p> <h4 id="工作原理-3"><a href="#工作原理-3" class="header-anchor">#</a> 工作原理</h4> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230826124610616.png" alt="image-20230826124610616"></p> <h4 id="初始标记阶段"><a href="#初始标记阶段" class="header-anchor">#</a> 初始标记阶段</h4> <p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即<code>初始标记阶段</code>、<code>并发标记阶段</code>、<code>重新标记阶段</code>和<code>并发清除阶段</code>。</p> <p>🤝在下面的图中，有这样一个约定：</p> <ul><li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li> <li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象</li> <li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li></ul> <p><strong>初始标记</strong>（<code>Initial-Mark</code>）阶段：在这个阶段中，程序中所有的工作线程都将会因为<code>Stop-the-World</code>机制而出现短暂的暂停，这个阶段的主要任务<code>仅仅只是标记出GCRoots能直接关联到的对象</code>，这个<code>GC Roots</code> 仅仅是老年代的 <code>GC Roots</code> 。一旦标记完成之后就会恢复之前被暂停的所有应用线程。同时初始标记不用去解决跨代引用（新生代引用老年代）问题，这个问题需要留在 <strong>remark</strong> 阶段去解决。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p><code>引用是有向的</code>，对象只有被黑色对象引用才能存活，否则，如果没有黑色对象引用它，它再如何引用其他对象都是会消亡的</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230826173902591.png" alt="image-20230826173902591"></p> <p>A 对象作为跨代引用对象不会在<strong>初始标记</strong>阶段进行标记，在老年代直接和 <code>GC Roots</code> 关联的对象引用会被压入标记栈（<strong>marking stack</strong>）。</p> <h4 id="并发标记阶段"><a href="#并发标记阶段" class="header-anchor">#</a> 并发标记阶段</h4> <p><strong>并发标记</strong>（<code>Concurrent-Mark</code>）阶段：<strong>concurrent-mark</strong> 阶段不需要 <code>Stop The World</code>，从GC Roots的<code>直接关联对象开始遍历整个对象图的过程</code>，这个过程<code>耗时较长</code>但是<code>不需要停顿用户线程</code>，可以与垃圾收集线程一起并发运行。具体做法弹出标记栈记录的对象引用，将本对象引用指向的其他对象引用压入标记栈等待被标记，同时标记本对象引用为存活对象。同时整个过程应用线程也在不断更改引用，新创建对象等。</p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230826173709948.png" alt="image-20230826173709948"></p> <ul><li>A 对象引用：在initial-mark 阶段时，跨代引用的对象会在 remark 阶段进行标记</li> <li>B 对象引用：B 对象是在 concurrent-sweep 阶段，触发YGC存活到老年代对象，或者是直接分配在老年代的大对象，B 对象被 GC Roots 直接关联。这部分对象会在 remark 阶段进行标记</li> <li>C 对象引用：C 对象也是在 concurrent-mark 阶段进入到老年代的对象，这部分标记和 A 对象一样，属于跨代引用，会在 remark 阶段进行标记。</li> <li>F 对象引用：F 对象是在引用树被扫描过程中，发送了<code>引用变更</code>。在遍历标记 D 对象的时候，它还没有引用 F 对象，引用树继续往下遍历标记，当遍历到 E 对象的时候，E 断开引用 F 对象，转而 F 对象被 D 对象引用，导致 F 对象漏标。怎么解决这个问题呢？<strong>CMS</strong> 采用了<code>增量更新（Incremental Update）方法</code>。</li> <li>1、2对象由于不是被黑色引用，所以1、2对象是会消亡的。</li></ul> <p>🔍我们重点分析虚线部分的对象标记过程？</p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/20230826173414.png" alt="20230826173414"></p> <p>Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生<code>对象消失</code>的问题，即原本应该是黑色的对象被误标为白色</p> <ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</li> <li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul> <p><code>赋值器是负责将新的引用插入到对象中，并删除不再需要的引用。</code></p> <p>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。</p> <p><strong>增量更新</strong></p> <p>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p> <p><strong>原始快照</strong></p> <p>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p> <h4 id="重新标记阶段"><a href="#重新标记阶段" class="header-anchor">#</a> 重新标记阶段</h4> <p><strong>重新标记</strong>（<code>Remark</code>）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此<code>为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（导致漏标、少标的对象）</code>，这个阶段的<code>Stop-the-World</code>停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p> <blockquote><p>就是上面的A、B、C、F类型对象</p></blockquote> <ul><li><p>GC Roots（老年代）：解决 B 类对象问题，在并发阶段，新晋老年代且和 GC Roots 直接相连的对象，它会基于整个对象引用树遍历下去</p> <blockquote><p>注意，与 GC Roots 直接相连的对象，如果在并发标记阶段已经被标记过了，则不会继续基于对象引用树遍历下去</p></blockquote></li> <li><p>新生代：解决 A、C 类对象问题。新生代跨代引用老年代问题通过扫描新生代来解决。</p></li> <li><p>card table + mod-union table：解决 F 类对象问题。通过扫描/标记 dirty card 里对象，来解决并发标记阶段引用变更问题</p></li> <li><p>CMS 在这个阶段任务还是比较重的，特别是在新生代比较大的情况下。</p></li> <li><p>CMS算法中提供了一个参数：-XX:+CMSScavengeBeforeRemark，默认并没有开启，如果开启该参数，在执行 remark 阶段之前，会强制触发一次 YGC，可以减少新生代对象的遍历时间。</p></li></ul> <h4 id="并发清除阶段"><a href="#并发清除阶段" class="header-anchor">#</a> 并发清除阶段</h4> <p><strong>并发清除</strong>（<code>Concurrent-Sweep</code>）阶段：此阶段<code>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</code>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p> <hr> <p>尽管CMS收集器采用的是并发回收（非独占式），但是在其<code>初始化标记和再次标记这两个阶段中仍然需要执行</code>Stop-the-World<code>机制</code>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“<code>top-the-World</code>，只是尽可能地缩短暂停时间。</p> <p><code>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</code></p> <p>另外，由于在垃圾收集阶段用户线程没有中断，所以在<code>CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用</code>。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<code>Concurrent Mode Failure</code>失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p> <p>CMS收集器的垃圾收集算法采用的是<code>标记清除算法</code>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<code>产生一些内存碎片</code>。那么CMS在为新对象分配内存空间时，将无法使用<code>指针碰撞（Bump the Pointer）技术</code>，而只能够选择<code>空闲列表（Free List）执行内存分配</code>。</p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230826133804626.png" alt=""></p> <p><strong>❓在这里可能有的同学会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢</strong></p> <p>使用Mark Compact算法的确可以解决内存碎片的问题，但它也存在一些缺点。首先，Mark Compact算法需要在压缩阶段将所有活动对象移动到一端，这可能会导致较大的内存移动开销。其次，由于需要移动对象，Mark Compact算法可能会导致较长的垃圾回收停顿时间，影响程序的响应性能。</p> <p>答案其实很简单，因为当<code>并发清理</code>的时候，用Mark Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响，如果这时候使用Mark Compact整理内存，那么对象的内存地址就发生变化，导致用户线程所使用到的对象受到影响。Mark Compact算法适合在<code>Stop the World</code>这种场景下使用。</p> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <p><code>并发收集</code>：CMS收集器在进行垃圾回收时，尽可能减少对用户线程的停顿时间，使得应用程序的响应速度更快。</p> <p><code>分步处理</code>：CMS收集器采用分步处理的方式，将垃圾回收过程分为多个阶段，可以与用户线程交替执行，减少对用户程序的影响。</p> <p><code>低延迟</code>：由于CMS收集器的并发特性，它可以在垃圾回收的同时，允许应用程序继续执行，从而减少了停顿时间，提高了系统的响应性能。</p> <h4 id="弊端"><a href="#弊端" class="header-anchor">#</a> 弊端</h4> <p><code>CPU敏感</code>：CMS收集器对处理器资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但会占用一部分线程（或处理器的计算能力），导致应用程序变慢，降低总吞吐量。特别是在处理器核心数量不足四个的情况下，可能会导致用户程序的执行速度大幅降低。</p> <p><code>内存碎片</code>：CMS收集器无法进行整理内存，只能进行标记和清理操作。这可能导致内存碎片的产生，使得内存空间不连续，影响内存的利用效率。</p> <p><code>浮动垃圾</code>：由于CMS收集器无法处理浮动垃圾（Floating Garbage），在并发标记和清理阶段，用户线程仍在继续运行，<code>用户线程可能会产生新的垃圾对象</code>。这些垃圾对象无法在当前收集中处理，只能留待下一次垃圾收集时清理，增加了垃圾回收的负担。</p> <p><code>并发失败</code>：CMS收集器在运行期间需要预留一部分内存空间给用户线程使用，以保证用户线程的正常运行。如果预留的内存无法满足程序分配新对象的需求，就会出现并发失败（Concurrent Mode Failure），此时虚拟机会启动后备预案，冻结用户线程的执行，临时启用Serial Old收集器进行老年代的垃圾收集，导致较长的停顿时间。</p> <h4 id="参数设置"><a href="#参数设置" class="header-anchor">#</a> 参数设置</h4> <ul><li><p><code>-XX:+UseConcMarkSweepGC</code>手动指定使用CMS收集器执行内存回收任务。
开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young区用）+CMS（Old区用）+ Serial Old的组合。</p></li> <li><p><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p></li> <li><ul><li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%。</li></ul></li> <li><ul><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</li></ul></li> <li><p><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p></li> <li><p><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次Full GC后对内存空间进行压缩整理。</p></li> <li><p><code>-XX:ParallelcMSThreads</code> 设置CMS的线程数量。</p></li> <li><ul><li>CMS默认启动的线程数是<code>（ ParallelGCThreads + 3 ）/ 4</code>，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul> <h4 id="jdk后续版本中cms的变化"><a href="#jdk后续版本中cms的变化" class="header-anchor">#</a> JDK后续版本中CMS的变化</h4> <p>JDK9新特性：CMS被标记为Deprecate了（JEP291）</p> <ul><li><p>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230826143956965.png" alt="image-20230826143956965"></p></li></ul> <p>JDK14新特性：删除CMS垃圾回收器（JEP363）</p> <ul><li>移除了CMS垃圾收集器，如果在JDK14中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li></ul> <h3 id="g1回收器-区域化分代式"><a href="#g1回收器-区域化分代式" class="header-anchor">#</a> G1回收器：区域化分代式</h3> <h4 id="g1概述"><a href="#g1概述" class="header-anchor">#</a> G1概述</h4> <blockquote><p>GarbageFirst（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p></blockquote> <p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p> <p>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起<code>全功能收集器</code>的重任与期望。</p> <h4 id="g1发展历程"><a href="#g1发展历程" class="header-anchor">#</a> G1发展历程</h4> <ol><li><strong>提出概念：</strong> G1垃圾回收器的概念最早由Sun Microsystems的垃圾回收专家Tony Printezis提出。他在一篇研究论文中提出了一种新型的垃圾回收器，旨在解决CMS垃圾回收器在处理大堆内存时的一些性能和可预测性问题。</li> <li><strong>原型实现：</strong> Sun Microsystems开始着手实现G1垃圾回收器的原型。这个早期版本用于验证G1的设计理念和可行性。</li> <li><strong>JDK6 Update 14：</strong> G1垃圾回收器<code>首次发布在JDK6 Update 14</code>中。然而，它仍然被标记为实验性选项，并未默认启用。</li> <li>**JDK7 Update 4：**随着JDK7 Update4的发布，移除了<code>Experimental</code>的标识。</li> <li>**JDK8 Update 40：**G1提供并发的类卸载的支持，补全了其计划功能的最后一块拼图。</li> <li>**JDK9：**取代Parallel Scavenge + Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。</li></ol> <h4 id="为什么叫g1"><a href="#为什么叫g1" class="header-anchor">#</a> 为什么叫G1</h4> <ul><li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region（区域）来表示Eden、幸存者0区，幸存者1区，老年代等。</li> <li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。<code>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值）</code>，在后台维护一个优先列表，每次根据允许的收集时间，<code>优先回收价值最大的Region</code>。</li> <li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</li></ul> <h4 id="g1回收器的特点"><a href="#g1回收器的特点" class="header-anchor">#</a> G1回收器的特点</h4> <p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p> <h5 id="并行与并发"><a href="#并行与并发" class="header-anchor">#</a> <strong>并行与并发</strong></h5> <ul><li><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。</p></li> <li><p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</p></li></ul> <h5 id="分代收集"><a href="#分代收集" class="header-anchor">#</a> <strong>分代收集</strong></h5> <ul><li><p>从分代上看，<code>G1依然属于分代型垃圾回收器</code>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p></li> <li><p>将<code>堆空间分为若干个区域（Region）</code>，这些区域中包含了<code>逻辑上的年轻代和老年代</code>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p></li> <li><p>和之前的各类回收器不同，它同时<code>兼顾年轻代和老年代</code>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</p></li></ul> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230828210956697.png" alt="image-20230828210956697"></p> <h5 id="空间整合"><a href="#空间整合" class="header-anchor">#</a> 空间整合</h5> <ul><li><p>CMS：<code>标记-清除</code>算法、内存碎片、若干次GG后就进行一次碎片整理。</p></li> <li><p>G1将内存划分为一个个的Region。内存的回收是以Region作为基本单位的。<code>Region之间是复制算法</code>，但整体上实际可看作是<code>标记-压缩（Mark-Compact）算法</code>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p></li></ul> <h5 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="header-anchor">#</a> 可预测的停顿时间模型</h5> <p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型</p> <p>能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是符合了实时Java（RTSJ）中软实时垃圾收集器的特征。</p> <ul><li><p>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p></li> <li><p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p></li> <li><p>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p></li></ul> <h4 id="g1回收器的缺点"><a href="#g1回收器的缺点" class="header-anchor">#</a> G1回收器的缺点</h4> <ol><li>内存占用：G1垃圾收集器需要维护额外的数据结构来管理堆内存，这会导致一定的内存占用。相比于其他垃圾收集器，G1垃圾收集器需要更多的堆内存。</li> <li>在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在堆大小在6-8GB之间。</li></ol> <h4 id="g1回收器的参数设置"><a href="#g1回收器的参数设置" class="header-anchor">#</a> G1回收器的参数设置</h4> <ul><li><p><code>-XX:+UseG1GC</code>：手动指定使用G1垃圾收集器执行内存回收任务</p></li> <li><p><code>-XX:G1HeapRegionSize</code> 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存大小的1/2000。</p></li> <li><p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms（人的平均反应速度）</p></li> <li><p><code>-XX:+ParallelGCThread</code> 设置并行GC线程数的值。最多设置为8（上面说过Parallel回收器的线程计算公式，当CPU_Count &gt; 8时，ParallelGCThreads 也会大于8）</p></li> <li><p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</p></li> <li><p><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li></ul> <h4 id="g1收集器的常见操作步骤"><a href="#g1收集器的常见操作步骤" class="header-anchor">#</a> G1收集器的常见操作步骤</h4> <p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p> <ul><li><p>第一步：开启G1垃圾收集器</p></li> <li><p>第二步：设置堆的最大内存</p></li> <li><p>第三步：设置最大的停顿时间</p></li></ul> <p>G1中提供了三种垃圾回收模式：Young GC、Mixed GC和Full GC，在不同的条件下被触发。</p> <h4 id="分区region-化整为零"><a href="#分区region-化整为零" class="header-anchor">#</a> 分区Region-化整为零</h4> <p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p> <p><code>-XX:G1HeapRegionSize</code>设定。<code>所有的Region大小相同，且在JVM生命周期内不会被改变。</code></p> <p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。<code>通过Region的动态分配方式实现逻辑上的连续。</code></p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230828210956697.png" alt="image-20230828210956697"></p> <p>一个region有可能属于Eden，Survivor或者Old内存区域。但是一个region只可能属于一个角色。</p> <p>**图中的E：**表示该region属于Eden内存区域。</p> <p>**图中的S：**表示属于survivor内存区域。</p> <p>**图中的O：**表示属于Old内存区域。</p> <p>**图中空白：**表示未使用的内存空间。</p> <p>G1垃圾收集器还增加了一种新的内存区域，叫做<code>Humongous</code>内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p> <p>**设置H的原因：**对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p> <h4 id="跨region引用对象问题"><a href="#跨region引用对象问题" class="header-anchor">#</a> 跨Region引用对象问题？</h4> <p>解决的思路是使用记忆集避免全堆作为GCRoots扫描（在垃圾收集相关概念的时候讲过）。</p> <p>但在G1收集器上记忆集的应用其实要复杂很多，<code>它的每个Region都维护有自己的记忆集</code>，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。</p> <p>G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。</p> <p>根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。</p> <h4 id="g1垃圾回收器的回收过程"><a href="#g1垃圾回收器的回收过程" class="header-anchor">#</a> G1垃圾回收器的回收过程</h4> <p>G1 GC的垃圾回收过程主要包括如下三个环节：</p> <ul><li><p>年轻代GC（Young GC）</p> <p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p></li> <li><p>老年代并发标记过程（Concurrent Marking）</p> <p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p></li> <li><p>混合回收（Mixed GC）如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。</p> <p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p></li></ul> <p><code>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</code></p> <p><img src="https://gitee.com/studentgitee/note-picture/raw/master/image-20230909105121326.png" alt="image-20230909105121326"></p> <h3 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="header-anchor">#</a> 垃圾回收器总结</h3> <h3 id="gc日志分析"><a href="#gc日志分析" class="header-anchor">#</a> GC日志分析</h3> <h4 id="minor-gc日志"><a href="#minor-gc日志" class="header-anchor">#</a> Minor GC日志</h4> <h4 id="full-gc日志"><a href="#full-gc日志" class="header-anchor">#</a> Full GC日志</h4> <h3 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="header-anchor">#</a> 垃圾回收器的新发展</h3> <h4 id="jdk11新特性"><a href="#jdk11新特性" class="header-anchor">#</a> JDK11新特性</h4> <h4 id="open-jdk12的shenandoash-gc"><a href="#open-jdk12的shenandoash-gc" class="header-anchor">#</a> Open JDK12的Shenandoash GC</h4> <h4 id="令人震惊、革命性的zgc"><a href="#令人震惊、革命性的zgc" class="header-anchor">#</a> 令人震惊、革命性的ZGC</h4></div></div></div></div>  <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/01/25, 17:13:40</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/9777ac/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">垃圾收集相关概念</div></a> <a href="/pages/c833ef/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">class文件结构</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/9777ac/" class="prev">垃圾收集相关概念</a></span> <span class="next"><a href="/pages/c833ef/">class文件结构</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2024
    <span>Gping | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.57e44612.js" defer></script><script src="/assets/js/2.ea24d1ee.js" defer></script><script src="/assets/js/31.044a932c.js" defer></script>
  </body>
</html>

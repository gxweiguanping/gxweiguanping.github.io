(window.webpackJsonp=window.webpackJsonp||[]).push([[190],{520:function(a,e,t){"use strict";t.r(e);var s=t(8),v=Object(s.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"序列化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#序列化"}},[a._v("#")]),a._v(" 序列化")]),a._v(" "),e("h2",{attrs:{id:"什么是序列化-什么是反序列化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是序列化-什么是反序列化"}},[a._v("#")]),a._v(" 什么是序列化？什么是反序列化？")]),a._v(" "),e("p",[a._v("序列化就是将对象的状态转换为字节流，从而可以将其持久化到硬盘，或通过网络将其发送到任何其他运行 Java 的设备。")]),a._v(" "),e("p",[a._v("反序列化是将这种字节流重新转化为对应的对象。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B.drawio.png",alt:"序列化过程.drawio"}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/113822150507073.png",alt:"113822150507073"}})]),a._v(" "),e("p",[a._v("类比我们生活中一些大件物品的运输，运输的时候把它拆了打包，用的时候再拆包组装。")]),a._v(" "),e("h3",{attrs:{id:"serializable接口有什么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serializable接口有什么用"}},[a._v("#")]),a._v(" Serializable接口有什么用？")]),a._v(" "),e("p",[a._v("Serializable接口是Java提供的一个标记接口，用于标识类可以被序列化。")]),a._v(" "),e("p",[a._v("实现Serializable接口的类可以将对象转换为字节流进行传输和存储，实现数据的持久化和跨平台的数据交换。")]),a._v(" "),e("h3",{attrs:{id:"serialversionuid-又有什么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serialversionuid-又有什么用"}},[a._v("#")]),a._v(" serialVersionUID 又有什么用？")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" serialVersionUID "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1L")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("serialVersionUID是Java中用于序列化和反序列化的一个特殊字段。它是一个静态常量，用于标识序列化类的版本号。")]),a._v(" "),e("p",[a._v("serialVersionUID的作用主要有两个：")]),a._v(" "),e("ol",[e("li",[a._v("版本控制 ：当一个类被序列化后，如果后续对该类进行了修改，例如添加、删除或修改了类的属性、方法等，那么序列化和反序列化时可能会出现版本不一致的问题。为了避免这种问题，可以在类中显式地定义serialVersionUID字段，并确保在类的修改后，serialVersionUID的值保持不变。当反序列化时，会比较序列化类的版本号和当前类的版本号是否一致，如果不一致，则会抛出\nInvalidClassException异常。")]),a._v(" "),e("li",[a._v("兼容性 ：当一个类的实例被序列化后，如果在后续的版本中对该类进行了修改，但是仍然希望能够反序列化之前的序列化数据，那么可以通过显式地指定serialVersionUID来保持兼容性。如果新版本的类和旧版本的类具有相同的serialVersionUID，那么即使类的结构发生了变化，仍然可以成功反序列化之前的序列化数据。")])]),a._v(" "),e("p",[a._v("需要注意的是，serialVersionUID的值是一个64位的long类型数字，可以手动指定，也可以自动生成。如果不显式地指定serialVersionUID，Java会根据类的结构自动生成一个值。但是建议在类中显式地定义serialVersionUID，以确保版本控制和兼容性。")]),a._v(" "),e("h3",{attrs:{id:"java-序列化不包含静态变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-序列化不包含静态变量"}},[a._v("#")]),a._v(" Java 序列化不包含静态变量？")]),a._v(" "),e("blockquote",[e("p",[a._v("Java序列化只会保存对象的非静态成员变量，不包含静态变量。静态变量属于类的状态信息，在序列化时不需要保存。虽然静态变量不会被序列化，但是它们的值在反序列化后会被恢复。")])]),a._v(" "),e("blockquote",[e("p",[a._v("序列化保存的是对象的状态（属性值)，不是整个类。")])]),a._v(" "),e("p",[a._v("假设我们有一个Java类"),e("code",[a._v("Person")]),a._v("，其中包含属性"),e("code",[a._v("name")]),a._v("、"),e("code",[a._v("age")]),a._v("和"),e("code",[a._v("gender")]),a._v("。当我们创建一个"),e("code",[a._v("Person")]),a._v("对象并为这些属性赋予值时，这些属性和对应的属性值都会一起进行序列化，就像是一起被装进了一个盒子里。")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Person")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Serializable")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" age"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" gender"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 构造方法等省略...")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br")])]),e("p",[a._v("现在，当我们对"),e("code",[a._v("Person")]),a._v("对象进行序列化时，不仅会将"),e("code",[a._v("name")]),a._v("、"),e("code",[a._v("age")]),a._v("和"),e("code",[a._v("gender")]),a._v("这些属性名称序列化，也会将这些属性的具体值一并打包进盒子（序列化）。这样，在进行反序列化时，我们就可以重新获取到对象的属性名称以及对应的属性值，从而得到完整的"),e("code",[a._v("Person")]),a._v("对象。")]),a._v(" "),e("p",[a._v("当对象进行序列化时，会将以下信息一并打包进盒子（序列化）里面：")]),a._v(" "),e("ol",[e("li",[a._v("属性名称（Field Names）：对象的属性名称（成员变量名），这些属性在类中定义。")]),a._v(" "),e("li",[a._v("属性值（Field Values）：与对象相关联的属性值，也就是对象的状态。这些属性值对应着属性名称。")]),a._v(" "),e("li",[a._v("类信息（Class Information）：对象所属的类的信息，包括类名、包名、父类等。这是为了在反序列化时能够正确地还原对象的类。")]),a._v(" "),e("li",[a._v("类型签名（Type Signatures）：用于标识对象类型的一些信息，确保反序列化时能正确地转换成对应的类。")]),a._v(" "),e("li",[a._v("版本号（Version Number）：用于处理序列化和反序列化时的版本控制，确保兼容性。如果版本号相同，说明序列化类和当前类版本一致，可以成功反序列化。如果版本号不同，JVM会判断类的版本是否兼容，如果不兼容，则会抛出InvalidClassException异常。")]),a._v(" "),e("li",[a._v("其他辅助信息：可能还包括一些辅助信息，如关于对象的继承关系、是否实现了特定接口等。")])]),a._v(" "),e("p",[a._v("这些信息都被打包成一个字节流，并存储在文件中或通过网络传输。在进行反序列化时，这个字节流会被还原成原始的对象，包括属性名称和对应的属性值，从而重建了原来的对象状态。")]),a._v(" "),e("blockquote",[e("p",[a._v("不是所有的信息都是必需的，具体取决于序列化的方式和实现。不同的序列化框架和协议可能会对信息的打包方式有所不同，但通常会包括上述所述的基本信息。")])]),a._v(" "),e("blockquote",[e("p",[a._v("方法是没有被序列化的。")])]),a._v(" "),e("p",[a._v("这是因为在序列化过程中，主要关注的是对象的状态（属性值），而不是对象的行为（方法）。序列化是用来保存对象的状态，以便在需要时能够恢复对象的状态，而方法是对象的行为，与对象的状态无关。")]),a._v(" "),e("h3",{attrs:{id:"如果有些变量不想序列化-怎么办"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果有些变量不想序列化-怎么办"}},[a._v("#")]),a._v(" 如果有些变量不想序列化，怎么办？")]),a._v(" "),e("p",[a._v("对于不想进行序列化的变量，使用 "),e("code",[a._v("transient")]),a._v(" 关键字修饰。")]),a._v(" "),e("p",[e("code",[a._v("transient")]),a._v("关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化。当对象被反序列化时，被 "),e("code",[a._v("transient")]),a._v(" 修饰的变量值不会被持久化和恢复。"),e("code",[a._v("transient")]),a._v("只能修饰变量，不能修饰类和方法。")]),a._v(" "),e("h2",{attrs:{id:"源码解析序列化和反序列化过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码解析序列化和反序列化过程"}},[a._v("#")]),a._v(" 源码解析序列化和反序列化过程")]),a._v(" "),e("p",[a._v("序列化的主要过程如下：")]),a._v(" "),e("ol",[e("li",[a._v("创建一个ObjectOutputStream对象：该对象将数据以字节流的形式写入输出流中。")]),a._v(" "),e("li",[a._v("调用ObjectOutputStream的writeObject()方法：该方法将要序列化的对象写入输出流中。")]),a._v(" "),e("li",[a._v("序列化过程中，会递归地对对象的所有引用对象进行序列化，直到所有相关对象都被序列化为止。")]),a._v(" "),e("li",[a._v("对象的序列化过程中，会调用对象的writeObject()方法（如果有定义）来自定义序列化过程。")]),a._v(" "),e("li",[a._v("对于基本数据类型和一些特殊类型，Java内部提供了默认的序列化和反序列化方法。")]),a._v(" "),e("li",[a._v("对于非Serializable的对象，或者无法进行序列化的对象，会抛出NotSerializableException。")])]),a._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/Student%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B.drawio1.png",alt:"Student对象序列化过程.drawio1"}})]),a._v(" "),e("p",[a._v("反序列化的主要过程是将字节流还原为对象的过程。在Java中，反序列化主要通过"),e("code",[a._v("ObjectInputStream")]),a._v("来实现。以下是反序列化的主要步骤：")]),a._v(" "),e("ol",[e("li",[a._v("创建"),e("code",[a._v("ObjectInputStream")]),a._v("对象：首先，需要创建一个"),e("code",[a._v("ObjectInputStream")]),a._v("对象，该对象用于从字节流中读取数据并还原对象。")]),a._v(" "),e("li",[a._v("从字节流中读取数据："),e("code",[a._v("ObjectInputStream")]),a._v("会读取字节流中的数据，按照之前序列化的顺序和格式进行读取。根据序列化时写入的标记和句柄，"),e("code",[a._v("ObjectInputStream")]),a._v("能够正确地还原对象的类型和结构。")]),a._v(" "),e("li",[a._v("根据标记和句柄还原对象：在读取字节流的过程中，"),e("code",[a._v("ObjectInputStream")]),a._v("根据之前序列化时写入的标记和句柄来还原对象。如果字节流中包含引用其他对象的句柄，"),e("code",[a._v("ObjectInputStream")]),a._v("会根据句柄将引用替换为实际的对象。")]),a._v(" "),e("li",[a._v("递归还原：如果序列化的对象中包含其他引用类型的对象，"),e("code",[a._v("ObjectInputStream")]),a._v("会递归地还原这些对象，确保所有相关对象都正确还原。")]),a._v(" "),e("li",[a._v("自定义反序列化：对于实现了"),e("code",[a._v("readObject()")]),a._v("方法的类，"),e("code",[a._v("ObjectInputStream")]),a._v("会调用该方法来自定义反序列化过程。这使得开发者可以在反序列化时对对象的属性进行特殊处理。")]),a._v(" "),e("li",[a._v("对象还原完成：当所有的对象和引用都正确还原后，反序列化过程完成，"),e("code",[a._v("ObjectInputStream")]),a._v("返回还原后的对象。")])]),a._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/student%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B1.drawio.png",alt:"student反序列化对象过程1.drawio"}})]),a._v(" "),e("h2",{attrs:{id:"说说有哪些常见的序列化方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说说有哪些常见的序列化方式"}},[a._v("#")]),a._v(" 说说有哪些常见的序列化方式？")]),a._v(" "),e("p",[a._v("Java中常见的序列化方式有以下几种：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240308143819721.png",alt:"image-20240308143819721"}})]),a._v(" "),e("ol",[e("li",[e("p",[a._v("Java对象流序列化（Java Serialization） ：Java对象流序列化是Java标准库提供的一种序列化方式，通过实现Serializable接口和Externalizable接口来实现对象的序列化和反序列化。Java序列化可以将对象序列化为字节流，也可以将对象序列化为JSON、XML等格式。")])]),a._v(" "),e("li",[e("p",[a._v("JSON序列化 ：JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，常用于Web应用中。Java中可以使用第三方库，如Jackson、Gson等，将对象序列化为JSON格式，也可以将JSON格式的数据反序列化为Java对象。")])]),a._v(" "),e("li",[e("p",[a._v("XML序列化 ：XML（Extensible Markup Language）是一种标记语言，常用于Web应用中。Java中可以使用第三方库，如JAXB、XStream等，将对象序列化为XML格式，也可以将XML格式的数据反序列化为Java对象。")])]),a._v(" "),e("li",[e("p",[a._v("Protobuf序列化 ：Protobuf（Protocol Buffers）是Google开发的一种高效的序列化协议，可以将结构化的数据序列化为紧凑的二进制格式。Java中可以使用Google提供的protobuf-java库，将对象序列化为Protobuf格式，也可以将Protobuf格式的数据反序列化为Java对象。")])]),a._v(" "),e("li",[e("p",[a._v("Hessian序列化 ：Hessian是一种基于HTTP的轻量级二进制序列化协议，可以将Java对象序列化为二进制格式，并通过HTTP协议进行传输。Java中可以使用第三方库，如Hessian、Dubbo等，将对象序列化为Hessian格式，也可以将Hessian格式的数据反序列化为Java对象。")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);
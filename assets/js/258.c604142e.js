(window.webpackJsonp=window.webpackJsonp||[]).push([[258],{589:function(s,t,e){"use strict";e.r(t);var a=e(8),r=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"分布式设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式设计"}},[s._v("#")]),s._v(" 分布式设计")]),s._v(" "),t("h2",{attrs:{id:"什么是幂等性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是幂等性"}},[s._v("#")]),s._v(" 什么是幂等性？")]),s._v(" "),t("p",[s._v("幂等性是一个数学概念，用在接口上：用在接口上就可以理解为：同一个接口，多次发出同一个请求，请求的结果是一致的。")]),s._v(" "),t("p",[t("strong",[s._v("简单说，就是多次调用如一次。")])]),s._v(" "),t("h2",{attrs:{id:"常见的幂等性问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的幂等性问题"}},[s._v("#")]),s._v(" 常见的幂等性问题？")]),s._v(" "),t("p",[s._v("1、用户在填写某些 form表单 时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样")]),s._v(" "),t("p",[s._v("2、开发人员在项目中为了解决 接口超时 问题，通常会引入了 重试机制 。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），于是会对该请求重试几次，这样也会产生重复的数据。")]),s._v(" "),t("p",[s._v("如果我们调用下游接口超时了，我们应该怎么处理呢?")]),s._v(" "),t("p",[s._v("有两种方案处理∶")]),s._v(" "),t("ul",[t("li",[s._v("方案一︰就是下游系统提供一个对应的查询接口。如果接口超时了，先查下对应的记录，如果查到是成功，就走成功流程，如果是失败，就按失败处理。")])]),s._v(" "),t("blockquote",[t("p",[s._v("拿支付例子来说，账务系统提供一个查询支付记录的接口，如果订单服务调用支付服务超时时，订单系统先去查询一下这笔记录，看下这笔转账记录成功还是失败，如果成功就走成功流程，失败再重试发起转账或者走另外的补偿机制")])]),s._v(" "),t("ul",[t("li",[s._v("方案二︰下游接口支持幂等，上游系统如果调用超时，发起重试即可。")])]),s._v(" "),t("p",[s._v("在分布式系统里，只要下游服务有写（保存、更新）的操作，都有可能会产生幂等性问题。")]),s._v(" "),t("p",[s._v("两种方案都是挺不错的，但是如果是MQ重复消费的场景，方案一处理并不是很妥，所以，我们还是要求下游系统对外接口支持幂等。")]),s._v(" "),t("blockquote",[t("p",[s._v("PS:幂等和防重有些不同，防重强调的防止数据重复，幂等强调的是多次调用如一次，防重包含幂等。")])]),s._v(" "),t("h2",{attrs:{id:"接口幂等性常见解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口幂等性常见解决方案"}},[s._v("#")]),s._v(" 接口幂等性常见解决方案")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240331112225346.png",alt:"image-20240331112225346"}})]),s._v(" "),t("ol",[t("li",[t("p",[s._v("insert前先select\n在保存数据的接口中，在 insert 前，先根据 requestId 等字段先 select 一下数据。如果该数据已存在，则直接返回，如果不存在，才执行 insert 操作。")])]),s._v(" "),t("li",[t("p",[s._v("加唯一索引\n加唯一索引是个非常简单但很有效的办法，如果重复插入数据，就会抛出异常，为了保证幂等性，一般需要捕获这个异常。")])])]),s._v(" "),t("p",[s._v("如果是 java 程序需要捕获： DuplicateKeyException 异常，如果使用了spring 框架还需要捕获：MySQLIntegrityConstraintViolationException 异常。")]),s._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("p",[s._v("加悲观锁\n更新逻辑，比如更新用户账户余额，可以加悲观锁，把对应用户的哪一行数据锁住。同一时刻只允许一个请求获得锁，其他请求则等待。")]),s._v(" "),t("div",{staticClass:"language-sql line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" id"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("123")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("update")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("加乐观锁\n更新逻辑，也可以用乐观锁，性能更好。可以在表中增加一个 timestamp 或者version 字段，例如 version :在更新前，先查询一下数据，将version也作为更新的条件，同时也更新version")]),s._v(" "),t("div",{staticClass:"language-sql line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("update")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("set")]),s._v(" amount"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("amount"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("version"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("version"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" id"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("123")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" version"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("更新成功后，version增加，重复更新请求进来就无法更新了。")])]),s._v(" "),t("li",[t("p",[s._v("建防重表\n有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，就可以使用防重表的方式。\n例如消息消费中，创建防重表，存储消息的唯一ID，消费时先去查询是否已经消费，已经消费直接返回成功。")])]),s._v(" "),t("li",[t("p",[s._v("状态机\n有些业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态，可以通过限制状态的流动来完成幂等。")])]),s._v(" "),t("li",[t("p",[s._v("分布式锁\n直接在数据库上加锁的做法性能不够友好，可以使用分布式锁的方式，目前最流行的分布式锁实现是通过Redis，具体实现一般都是使用Redission框架。")])]),s._v(" "),t("li",[t("p",[s._v("token机制")])])]),s._v(" "),t("p",[s._v("请求接口之前，需要先获取一个唯一的token，再带着这个token去完成业务操作，服务端根据这个token是否存在，来判断是否是重复的请求。")])])}),[],!1,null,null,null);t.default=r.exports}}]);
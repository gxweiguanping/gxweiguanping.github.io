(window.webpackJsonp=window.webpackJsonp||[]).push([[215],{544:function(e,t,r){"use strict";r.r(t);var s=r(8),n=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"mvc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[e._v("#")]),e._v(" MVC")]),e._v(" "),t("h2",{attrs:{id:"spring-mvc-的核心组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc-的核心组件"}},[e._v("#")]),e._v(" Spring MVC 的核心组件？")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("DispatcherServlet（前置控制器）")]),e._v(" ： DispatcherServlet是Spring MVC的核心控制器，负责接收HTTP请求并将请求分发给相应的处理器（Controller）进行处理。它充当了前端控制器的角色，负责协调整个请求处理过程。相当于总指挥。")]),e._v(" "),t("li",[t("strong",[e._v("HandlerMapping（处理器映射器）")]),e._v(" ： HandlerMapping负责将请求映射到相应的处理器（Controller）上。它根据请求的URL、请求方法等信息，确定请求应该由哪个处理器来处理。")]),e._v(" "),t("li",[t("strong",[e._v("HandlerAdapter（处理器适配器）")]),e._v(" ：Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。")]),e._v(" "),t("li",[t("strong",[e._v("Handler（处理器）")]),e._v(" ： Handler是实际处理请求的组件，通常是一个Controller类或者Controller方法。它接收请求并进行相应的业务处理，然后返回处理结果。")]),e._v(" "),t("li",[t("strong",[e._v("ViewResolver（视图解析器）")]),e._v(" ： ViewResolver负责将处理结果（ModelAndView）解析为具体的视图。它根据视图名称和相关配置，选择合适的视图解析器来解析视图，并返回给DispatcherServlet。")]),e._v(" "),t("li",[t("strong",[e._v("HandlerInterceptor（处理器拦截器）")]),e._v(" ：是一个接口，如果需要完成一些拦截处理，可以实现该接口。")]),e._v(" "),t("li",[t("strong",[e._v("HandlerExecutionChain（处理器执行链）")]),e._v(" ：包括两部分内容：Handler 和HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。")]),e._v(" "),t("li",[t("strong",[e._v("ModelAndView")]),e._v(" ：它充当了Handler（处理器）的处理结果，并将结果返回给DispatcherServlet。ModelAndView对象包含了模型数据和视图信息。")])]),e._v(" "),t("h2",{attrs:{id:"spring-mvc-的工作流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc-的工作流程"}},[e._v("#")]),e._v(" Spring MVC 的工作流程？")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/120050851575150.png",alt:"120050851575150"}})]),e._v(" "),t("ol",[t("li",[e._v("客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。")]),e._v(" "),t("li",[e._v("DispatcherServlet接收到请求后，根据HandlerMapping（处理器映射器）找到对应的处理器（Controller）。")]),e._v(" "),t("li",[e._v("DispatcherServlet将请求交给HandlerAdapter（处理器适配器）来执行处理器的业务逻辑。")]),e._v(" "),t("li",[e._v("处理器执行业务逻辑，封装处理结果到ModelAndView对象中，并返回给HandlerAdapter。")]),e._v(" "),t("li",[e._v("HandlerAdapter将ModelAndView返回给DispatcherServlet。")]),e._v(" "),t("li",[e._v("DispatcherServlet根据ModelAndView中的视图信息，通过ViewResolver（视图解析器）找到对应的View（视图）")]),e._v(" "),t("li",[e._v("DispatcherServlet将ModelAndView中的模型数据传递给View。")]),e._v(" "),t("li",[e._v("View将模型数据和视图模板结合，生成最终的响应结果。")]),e._v(" "),t("li",[e._v("DispatcherServlet将最终的响应结果返回给客户端。当然我们现在大部分的开发都是前后端分离，Restful风格接口，后端只需要返回Json数据就行了。")])]),e._v(" "),t("h2",{attrs:{id:"springmvc-restful风格的接口的流程是什么样的呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springmvc-restful风格的接口的流程是什么样的呢"}},[e._v("#")]),e._v(" SpringMVC Restful风格的接口的流程是什么样的呢？")]),e._v(" "),t("p",[e._v("我们都知道Restful接口，响应格式是json，这就用到了一个常用注解：")]),e._v(" "),t("p",[t("strong",[e._v("@ResponseBody")])]),e._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@GetMapping")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"/user"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@ResponseBody")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("User")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("user")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("User")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"张三"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("加入了这个注解后，整体的流程上和使用ModelAndView大体上相同，但是细节上有一些不同：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/704667325627139.png",alt:"704667325627139"}})]),e._v(" "),t("ol",[t("li",[t("p",[e._v("客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet")])]),e._v(" "),t("li",[t("p",[e._v("DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理")])]),e._v(" "),t("li",[t("p",[e._v("DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller")])]),e._v(" "),t("li",[t("p",[e._v("Controller被封装成了ServletInvocableHandlerMethod，HandlerAdapter处理器适配器去执行invokeAndHandle方法，完成对Controller的请求处理")])]),e._v(" "),t("li",[t("p",[e._v("HandlerAdapter执行完对Controller的请求，会调用HandlerMethodReturnValueHandler去处理返回值，主要的过程：")]),e._v(" "),t("ol",[t("li",[e._v("调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例")]),e._v(" "),t("li",[e._v("使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中")]),e._v(" "),t("li",[e._v("在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化")])])]),e._v(" "),t("li",[t("p",[e._v("执行完请求后，返回的ModelAndView为null，ServletServerHttpResponse里也已经写入了响应，所以不用关心View的处理")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);
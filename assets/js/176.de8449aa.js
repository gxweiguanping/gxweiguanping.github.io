(window.webpackJsonp=window.webpackJsonp||[]).push([[176],{506:function(t,e,a){"use strict";a.r(e);var r=a(8),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"kafka系统的架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kafka系统的架构"}},[t._v("#")]),t._v(" Kafka系统的架构")]),t._v(" "),e("p",[t._v("kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该具备的功能，但是确有着独特的设计。可以这样来说，Kafka借鉴了Java Message Service API（Java消息服务规范的思想，但是确并没有完全遵循JMS规范）。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/6aeef6938a711406fcb91d97df909fdc.png",alt:"6aeef6938a711406fcb91d97df909fdc"}})]),t._v(" "),e("p",[t._v("服务端(brokers)和客户端(producer、consumer)之间通信通过"),e("strong",[t._v("TCP协议")]),t._v("来完成。")]),t._v(" "),e("h2",{attrs:{id:"broker服务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#broker服务"}},[t._v("#")]),t._v(" Broker服务")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20231221121054995.png",alt:"image-20231221121054995"}})]),t._v(" "),e("p",[t._v("消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker可以组成一个Kafka集群。")]),t._v(" "),e("h2",{attrs:{id:"producer生产者"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#producer生产者"}},[t._v("#")]),t._v(" Producer生产者")]),t._v(" "),e("p",[t._v("消息生产者，向Broker发送消息的客户端，它不是kafka的组成部分")]),t._v(" "),e("h2",{attrs:{id:"consumer消费者"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#consumer消费者"}},[t._v("#")]),t._v(" Consumer消费者")]),t._v(" "),e("p",[t._v("消息消费者，从Broker读取消息的客户端，它不是kafka的组成部分")]),t._v(" "),e("h2",{attrs:{id:"topic主题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#topic主题"}},[t._v("#")]),t._v(" Topic主题")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20231221090717109.png",alt:"image-20231221090717109"}})]),t._v(" "),e("p",[t._v("Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic。生产者和消费者，都是通过连接主题 来处理消息。")]),t._v(" "),e("h2",{attrs:{id:"partition分区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#partition分区"}},[t._v("#")]),t._v(" partition分区")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20231221090701434.png",alt:"image-20231221090701434"}})]),t._v(" "),e("p",[t._v("kafka里存储消息的物理集合，一个主题可以划分为1个或多个分区，可以理解为子队列；\n"),e("code",[t._v("每个分区只属于一个主题，且只能被一个消费者消费(同一个组)")]),t._v("。\n该主题收到的所有消息，会根据消息的key选择对应的分区进行投递；\n如果消息未指定key，且没有定义分区规则时，则kafka会随机平均投递到主题的多个分区里。")]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),e("p",[t._v("每个分区里的消息，一定是按队列的规则，保证先进先出；但是不同的分区的消息，不能保证分区间的消息顺序。\n因此，如果要确保消费者能按消息的投递顺序进行消费")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20231221091138149.png",alt:"image-20231221091138149"}})]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),e("p",[t._v("当不指定key时（key值为空），kafka将会以轮询的方式将消息保存到每个分区里面")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20231221091521640.png",alt:"image-20231221091521640"}})]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),e("p",[t._v("当指定key时，kafka将会以轮询的方式将消息保存到每个分区里面")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20231221120608041.png",alt:"image-20231221120608041"}})]),t._v(" "),e("ul",[e("li",[t._v("每个主题只建一个分区（这个不推荐），可以保证所有消息的顺序，但是失去了拓展性和性能")]),t._v(" "),e("li",[t._v("同一批需要保证顺序的消息，指定相同的key，比如使用用户ID作为消息的key，相同key的消息会投递到同一个分区")])]),t._v(" "),e("h2",{attrs:{id:"consumergroup消费者组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#consumergroup消费者组"}},[t._v("#")]),t._v(" ConsumerGroup消费者组")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20231221091939749.png",alt:"image-20231221091939749"}})]),t._v(" "),e("p",[t._v("每个Consumer属于一个特定的Consumer Group，一条消息可以被多个不同的Consumer Group消费，但是一个Consumer Group中只能有一个Consumer能够消费该消息（"),e("strong",[t._v("一个分区不能同时被同一个消费者组里的多个消费者消费")]),t._v("）。")]),t._v(" "),e("p",[t._v("为什么这样设计？\n存在竞争关系，可能需要引入锁，导致性能下降，造成额外的开销。")]),t._v(" "),e("h2",{attrs:{id:"replica-副本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#replica-副本"}},[t._v("#")]),t._v(" Replica（副本）")]),t._v(" "),e("p",[t._v("一个 topic 的每个分区都有若干个副本，一个 Leader 和若干个 Follower，每个副本都存储一份完全相同的消息数据。一般建议同一个分区的不同副本，要保存在不同的broker上，避免broker故障导致该分区数据丢失。")]),t._v(" "),e("h2",{attrs:{id:"leader-follower"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#leader-follower"}},[t._v("#")]),t._v(" Leader/Follower")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20231221120824902.png",alt:"image-20231221120824902"}})]),t._v(" "),e("p",[t._v("每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 Leader。（leader对外提供读写服务）")]),t._v(" "),e("p",[t._v("每个分区多个副本中的“从”，实时从 Leader 中"),e("strong",[t._v("同步数据")]),t._v("，保持和 Leader 数据的同步。（follower只同步数据）")]),t._v(" "),e("p",[t._v("Leader 发生故障时，某个 Follower 会成为新的 Leader。")]),t._v(" "),e("h2",{attrs:{id:"消息偏移量-offset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息偏移量-offset"}},[t._v("#")]),t._v(" 消息偏移量 offset")]),t._v(" "),e("p",[t._v("分区中的每条记录都分配有一个顺序 ID 号，称为"),e("strong",[t._v("偏移量")]),t._v("，用于唯一标识分区中的每条记录，并且是从0开始递增的。主题+分区+偏移量，可以唯一定位一条消息。")]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),e("p",[t._v("每个分区里的每条消息，offset一定是不同的；不同分区的offset是会重复的。消费者会也记录每次消费的offset值，来标识自己当前处理到哪一条消息了，以便断开重连时，继续消费，消费者的offset也是存储在kafka中。")])]),t._v(" "),e("h2",{attrs:{id:"isr-in-sync-replicas"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#isr-in-sync-replicas"}},[t._v("#")]),t._v(" ISR(in-sync replicas)")]),t._v(" "),e("p",[t._v("每个分区的 leader 会维护一个 ISR 列表，ISR 列表里面就是 follower 副本的 Borker 编号， 只有跟得上 Leader 的 follower 副本才能加入到 ISR 里面， 这个是通过replica.lag.time.max.ms =10000（默认值）参数配置的，只有 ISR 里的成员才有被选为 leader 的可能。")]),t._v(" "),e("p",[t._v("replica.lag.time.max.ms =10000表示复制的延迟时间的上限。当一个备份副本的最大延迟时间超过了这个值，就会被认为是不同步的。")]),t._v(" "),e("p",[e("strong",[t._v("踢出 ISR 和重新加入 ISR 的条件：")])]),t._v(" "),e("ul",[e("li",[t._v("踢出 ISR 的条件： 由 replica.lag.time.max.ms =10000 决定；")]),t._v(" "),e("li",[t._v("重新加入 ISR 的条件： OSR 副本的 LEO（log end offset）追上 leader 的 LEO")])]),t._v(" "),e("h2",{attrs:{id:"消息传递语义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息传递语义"}},[t._v("#")]),t._v(" 消息传递语义")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("传递语义")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("最多一次")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("消息可能会丢失，永远不重复发送")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("最少一次")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("消息不会丢失，但是可能会重复")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("精确一次")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("保证消息被传递到服务端且在服务端不重复")])])])]),t._v(" "),e("h2",{attrs:{id:"kafka-的数据存储结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kafka-的数据存储结构"}},[t._v("#")]),t._v(" kafka 的数据存储结构")]),t._v(" "),e("h3",{attrs:{id:"kafka-的整体存储结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kafka-的整体存储结构"}},[t._v("#")]),t._v(" kafka 的整体存储结构")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240108171040119.png",alt:"image-20240108171040119"}})]),t._v(" "),e("h3",{attrs:{id:"物理存储目录结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#物理存储目录结构"}},[t._v("#")]),t._v(" 物理存储目录结构")]),t._v(" "),e("h4",{attrs:{id:"存储目录名称规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#存储目录名称规范"}},[t._v("#")]),t._v(" 存储目录名称规范")]),t._v(" "),e("blockquote",[e("p",[t._v("格式为："),e("strong",[t._v("topic名称-分区号")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240108171819330.png",alt:"image-20240108171819330"}})]),t._v(" "),e("p",[t._v("注："),e("code",[t._v("t1")]),t._v("即为一个 topic 的名称；\n而"),e("code",[t._v("t1-0 / t1-1")]),t._v("则表明这个目录是 t1 这个 topic 的哪个 partition；")]),t._v(" "),e("h4",{attrs:{id:"数据文件名称规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据文件名称规范"}},[t._v("#")]),t._v(" 数据文件名称规范")]),t._v(" "),e("p",[t._v("生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位效率低下，Kafka采取了分片和索引机制 。")]),t._v(" "),e("ol",[e("li",[t._v("每个 partition 的数据将分为多个 segment 存储")]),t._v(" "),e("li",[t._v("每个 segment 对应两个文件："),e("code",[t._v(".index")]),t._v("文件和"),e("code",[t._v(".log")]),t._v("文件。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240108172013497.png",alt:"image-20240108172013497"}})]),t._v(" "),e("p",[t._v("index 和 log 文件以当前 segment 的第一条消息的 offset 命名。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240108172112757.png",alt:"image-20240108172112757"}})]),t._v(" "),e("p",[t._v("index 索引文件中的数据为： 消息 offset -> log 文件中该消息的物理偏移量位置；")]),t._v(" "),e("p",[t._v("Kafka 中的索引文件以 稀疏索引（ sparse index ）的方式构造消息的索引，它并不保证每个消息在索引文件中都有对应的索引；")]),t._v(" "),e("p",[t._v("每当写入一定量（由 broker 端参数 log.index.interval.bytes 指定，默认值为 4096 ，即 4KB ）的消息时，偏移量索引文件和时间戳索引文件分别增加一个偏移量索引项和时间戳索引项，增大或减小 log.index.interval.bytes 的值，对应地可以缩小或增加索引项的密度；")]),t._v(" "),e("p",[t._v("查询指定偏移量时，使用二分查找法来快速定位偏移量的位置。")]),t._v(" "),e("h4",{attrs:{id:"消息-message-存储结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息-message-存储结构"}},[t._v("#")]),t._v(" 消息 message 存储结构")]),t._v(" "),e("p",[t._v("在客户端编程代码中，消息的封装类有两种：ProducerRecord、ConsumerRecord；")]),t._v(" "),e("p",[t._v("简单来说，kafka 中的每个 massage 由一对 key-value 构成；Kafka 中的 message 格式经历了 3 个版本的变化了：v0 、 v1 、 v2")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240108172727420.png",alt:"image-20240108172727420"}})]),t._v(" "),e("p",[t._v("字段介绍如下：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("字段")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("含义")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("crc")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("占用 4 个字节，主要用于校验消息的内容")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("magic")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("这个占用 1 个字节，主要用于标识 Kafka 版本。Kafka 0.10.x magic 默认值为 1")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("attributes")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("占用 1 个字节，这里面存储了消息压缩使用的编码以及 Timestamp 类型。目前 Kafka 支"),e("br"),t._v("持 gzip、snappy 以及 lz4（0.8.2 引入） 三种压缩格式；[0,1,2]三位 it 表示压缩类型。[3]位表示"),e("br"),t._v("时间错类型（0，create time；1，append time），[4,5,6,7]位保留")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("key length")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("占用 4 个字节。主要标识 Key 的内容的长度")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("key")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("占用 N 个字节，存储的是 key 的具体内容")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("value length")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("占用 4 个字节。主要标识 value 的内容的长度")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("value")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("value 即是消息的真实内容，在 Kafka 中这个也叫做 payload")])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);
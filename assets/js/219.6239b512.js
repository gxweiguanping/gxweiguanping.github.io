(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{549:function(t,e,a){"use strict";a.r(e);var s=a(8),r=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),e("h2",{attrs:{id:"mybatis的工作原理吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mybatis的工作原理吗"}},[t._v("#")]),t._v(" MyBatis的工作原理吗？")]),t._v(" "),e("p",[t._v("由服务员(SqlSession) 为你下单，然后交给后厨(Execute)制作，后厨他们分工合作职责分明，有做薯条的(SimpleExecutor)、有做汉堡(BaseExecutor)的、还有负责打包整理的(ResultHandler)。最后在由服务员交到你手上。服务员不能同时为两个顾客点单（SqlSession 不能同时为两个线程共用）。")]),t._v(" "),e("p",[t._v("最后这个方法代理MapperMethod 怎么表示呢？这就是叫外卖呀！太形像了。你的点餐过程被外卖公司代理了，但最终还是要由服务员接单，后厨制作。")]),t._v(" "),e("h2",{attrs:{id:"mybatis都有哪些executor执行器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mybatis都有哪些executor执行器"}},[t._v("#")]),t._v(" Mybatis都有哪些Executor执行器？")]),t._v(" "),e("p",[t._v("Executor是MyBatis执行者接口，我们在次确认一下，执行器的功能包括：")]),t._v(" "),e("ul",[e("li",[t._v("基本功能：改、查，没有增删的原因是，所有的增删操作都可以归结到改。")]),t._v(" "),e("li",[t._v("缓存维护：这里的缓存主要是为一级缓存服务，功能包括创建缓存Key、清理缓存、判断缓存是否存在。")]),t._v(" "),e("li",[t._v("事物管理：提交、回滚、关闭、批处理刷新。")])]),t._v(" "),e("p",[t._v("对于这个接口MyBatis是有三个实现子类。分别是："),e("strong",[t._v("SimpleExecutor(简单执行器)")]),t._v("、"),e("strong",[t._v("ReuseExecutor(可重用执行器)")]),t._v("、"),e("strong",[t._v("BatchExecutor(批处理执行器)")]),t._v("。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240313201715580.png",alt:"image-20240313201715580"}})]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("SimpleExecutor(简单执行器)")]),t._v(" ：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。这就会导致即使是相同SQL语句也"),e("strong",[t._v("无法重用Statement")]),t._v("，所以就有了（ReuseExecutor）可重用执行器。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("ReuseExecutor(可重用执行器)")]),t._v(" ：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，"),e("strong",[t._v("用完后，不关闭Statement对象，而是放置于Map<String,Statement>内，供下一次使用")]),t._v("。简言之，就是重复使用Statement对象。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("BatchExecutor(批处理执行器)")]),t._v("。 ： BatchExecutor 顾名思议，它就是用来作批处理的。但会将所 有SQL请求集中起来，最后调用Executor.flushStatements() 方法时一次性将所有请求发送至数据库。")]),t._v(" "),e("p",[t._v("这里它是利用了Statement中的addBath 机制吗？不一定，因为只有"),e("strong",[t._v("连续相同的SQL语句并且相同的SQL")]),t._v("映射声明，才会重用Statement，并利用其批处理功能。否则会构建一个新的Satement然后在flushStatements() 时一次执行。这么做的原因是它要保证执行顺序。跟调用顺序一致。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240313203951101.png",alt:"image-20240313203951101"}})]),t._v(" "),e("p",[t._v("假设上图中相同的线条颜色，就是相同的SQL语句。"),e("strong",[t._v("为了保证执行顺序只有绿色线条合并成一个Statement而两条黄线不能")]),t._v("，否则就会导致，后面的黄线先于中间的绿线执行，有违调用顺序。")])])]),t._v(" "),e("p",[t._v("前面我们所说Executor其中有一个职责是负责缓存维护，以及事物管理。这三执行器并没有涉及，这部分逻辑去哪了呢？别急，缓存和事物无论采用哪种执行器，都会涉及，这属于公共逻辑。所以就完全有必要三个类之上抽象出一个基础执行器用来处理公共逻辑。")]),t._v(" "),e("p",[e("strong",[t._v("基础执行器")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240313205104954.png",alt:"image-20240313205104954"}})]),t._v(" "),e("p",[e("strong",[t._v("缓存执行器")])]),t._v(" "),e("p",[t._v("查看Executor 的子类还有一个CachingExecutor,这是用于处理二级缓存的。为什么不把它和一级缓存一起处理呢？因为二级缓存和一级缓存相对独立的逻辑，而且二级缓存可以通过参数控制关闭，而一级缓存是不可以的。综上原因把二级缓存单独抽出来处理。抽取的方式采用了装饰者设计模式，即在CachingExecutor 对原有的执行器进行包装，处理完二级缓存逻辑之后，把SQL执行相关的逻辑交给实至的Executor处理。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240313205707975.png",alt:"image-20240313205707975"}})])])}),[],!1,null,null,null);e.default=r.exports}}]);
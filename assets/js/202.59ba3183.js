(window.webpackJsonp=window.webpackJsonp||[]).push([[202],{532:function(t,a,s){"use strict";s.r(a);var n=s(8),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"java内存模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型"}},[t._v("#")]),t._v(" Java内存模型")]),t._v(" "),a("h2",{attrs:{id:"说一下你对java内存模型-jmm-的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一下你对java内存模型-jmm-的理解"}},[t._v("#")]),t._v(" 说一下你对Java内存模型（JMM）的理解？")]),t._v(" "),a("p",[t._v("理解JMM之前，我们先来看一下并发环境下物理机会遇到什么问题？")]),t._v(" "),a("p",[a("strong",[t._v("并发下物理机问题1：硬件处理效率")])]),t._v(" "),a("p",[t._v("物理内存的第一个问题是：硬件处理效率。")]),t._v(" "),a("ul",[a("li",[t._v("绝大多数的运算任务都不可能只靠处理器“计算”就能完成，"),a("strong",[t._v("处理器至少需要与内存交互")]),t._v("，如读取运算数据、存储运算结果，这个 I/O 操作是很难消除的（无法仅靠寄存器完成所有运算任务）。")]),t._v(" "),a("li",[a("strong",[t._v("由于计算机的存储设备与处理器的运算速度有几个数量级的差距")]),t._v(" ，这种速度上的矛盾，会降低硬件的处理效率。所以，现代计算机都"),a("strong",[t._v("不得不加入高速缓存（Cache） 来作为内存和处理器之间的缓冲")]),t._v("。将需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步会内存中，这样处理器就无需等待缓慢的内存读写了。")])]),t._v(" "),a("p",[a("strong",[t._v("总结：")]),t._v(" 硬件中使用高速缓存来作为内存和处理器之间的缓冲，JMM内存模型与cpu缓存模型类似，是基于cpu缓存模型来建立的。")]),t._v(" "),a("p",[a("strong",[t._v("并发下物理机问题2：缓存一致性")])]),t._v(" "),a("p",[t._v("高速缓存解决了 "),a("strong",[t._v("硬件效率问题")]),t._v("，但是引入了一个新的问题："),a("strong",[t._v("缓存一致性（Cache Coherence）")]),t._v("。")]),t._v(" "),a("p",[t._v("在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。如果真的发生这种情况，那同步回到主内存时该以谁的缓存数据为准呢？")]),t._v(" "),a("p",[t._v("为了解决缓存一致性问题，"),a("strong",[t._v("需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。")])]),t._v(" "),a("p",[a("strong",[t._v("总结：")]),t._v(" JMM模型在这个问题上，使用volatile关键字，volatile的底层是使用MESI缓存一致性协议实现的，通过总线嗅探机制实现感知数据的变化，从而将自己缓存里的数据失效。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/e9ea12af19354259aaa30dba3c8c71c3.png",alt:"e9ea12af19354259aaa30dba3c8c71c3"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/ed0185f56ac6417fac9fed6ba98140f7.png",alt:"ed0185f56ac6417fac9fed6ba98140f7"}})]),t._v(" "),a("p",[t._v("JMM借鉴了物理机对于并发问题的处理策略，并给出了上图的JMM内存模型。 回到开头的问题：")]),t._v(" "),a("p",[a("strong",[t._v("为什么会有JMM？")])]),t._v(" "),a("ul",[a("li",[t._v("为了解决虚拟机的"),a("strong",[t._v("并发问题")]),t._v("，并"),a("strong",[t._v("屏蔽各种硬件和操作系统的内存访问的差异（cpu计算速度和内存IO速度差好几个数量级）")]),t._v("，借鉴了物理机遇到并发问题的处理方案。实现让Java程序在各个平台下都能达到一致的内存访问效果。")]),t._v(" "),a("li",[a("strong",[t._v("硬件软件处理速度差异问题：")]),t._v(" "),a("ul",[a("li",[t._v("利用工作内存（高速缓存）来解决")])])]),t._v(" "),a("li",[a("strong",[t._v("缓存数据一致性问题：")]),t._v(" "),a("ul",[a("li",[t._v("利用"),a("strong",[t._v("Volatile关键字")]),t._v("（缓存一致性协议）来解决，Volatile底层是使用"),a("strong",[t._v("MESI缓存一致性")]),t._v("协议实现的，通过"),a("strong",[t._v("总线嗅探机制")]),t._v("实现感知数据的变化，从而将自己缓存里的"),a("strong",[t._v("数据失效")]),t._v("。")])])])]),t._v(" "),a("h2",{attrs:{id:"jmm的内存结构和8个交互操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jmm的内存结构和8个交互操作"}},[t._v("#")]),t._v(" JMM的内存结构和8个交互操作")]),t._v(" "),a("p",[t._v("JMM规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，工作内存中保留了线程使用到的变量的主内存的副本。\n关于主内存与工作内存之间具体的交互协议，"),a("code",[t._v("即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节")]),t._v("，JMM定义了 8 个操作来完成主内存和工作内存之间的交互操作。JVM 实现时必须保证下面介绍的每种操作都是 "),a("strong",[t._v("原子的。")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("lock")]),t._v("（锁定）：作用于"),a("strong",[t._v("主内存")]),t._v("的变量，它把一个变量标识为一条线程独占的状态。")]),t._v(" "),a("li",[a("code",[t._v("unlock")]),t._v("（解锁）：作用于"),a("strong",[t._v("主内存")]),t._v("的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。")]),t._v(" "),a("li",[a("code",[t._v("read")]),t._v("（读取）：作用于"),a("strong",[t._v("主内存")]),t._v("的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的"),a("code",[t._v("load")]),t._v("动作使用。")]),t._v(" "),a("li",[a("code",[t._v("load")]),t._v("（载入）：作用于"),a("strong",[t._v("工作内存")]),t._v("的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。")]),t._v(" "),a("li",[a("code",[t._v("use")]),t._v("（使用）：作用于"),a("strong",[t._v("工作内存")]),t._v("的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。")]),t._v(" "),a("li",[a("code",[t._v("assign")]),t._v("（赋值）：作用于"),a("strong",[t._v("工作内存")]),t._v("的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。")]),t._v(" "),a("li",[a("code",[t._v("store")]),t._v("（存储）：作用于"),a("strong",[t._v("工作内存")]),t._v("的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的"),a("code",[t._v("write")]),t._v("操作使用。")]),t._v(" "),a("li",[a("code",[t._v("write")]),t._v("（写入）：作用"),a("strong",[t._v("于主内存")]),t._v("的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。")])]),t._v(" "),a("p",[t._v("如果要把一个变量从主内存拷贝到工作内存，那就要按顺序"),a("strong",[t._v("执行"),a("code",[t._v("read")]),t._v("和"),a("code",[t._v("load")]),t._v("操作")]),t._v("，如果要把变量从工作内存同步回主内存，就要按顺序"),a("strong",[t._v("执行"),a("code",[t._v("store")]),t._v("和"),a("code",[t._v("write")]),t._v("操作")]),t._v("。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。")]),t._v(" "),a("p",[a("strong",[t._v("JMM内存的8个交互操作流程")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/42f404d5bac145e4b938234002b6a1de.png",alt:"42f404d5bac145e4b938234002b6a1de"}})]),t._v(" "),a("h2",{attrs:{id:"说说你对原子性、可见性、有序性的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说你对原子性、可见性、有序性的理解"}},[t._v("#")]),t._v(" 说说你对原子性、可见性、有序性的理解？")]),t._v(" "),a("p",[a("code",[t._v("原子性")]),t._v("、"),a("code",[t._v("有序性")]),t._v("、"),a("code",[t._v("可见性")]),t._v("是并发编程中非常重要的基础概念，用于描述多线程环境下的内存访问行为，JMM的很多技术都是围绕着这三大特性展开。")]),t._v(" "),a("ul",[a("li",[t._v("原子性（Atomicity） ：原子性是指一个操作是不可分割的，要么完全执行，要么不执行。在多线程环境下，原子性保证了对共享变量的操作是原子的，不会被其他线程中断。")]),t._v(" "),a("li",[t._v("可见性（Visibility） ：可见性是指当一个线程对共享变量进行修改后，其他线程能够立即看到这个修改。在多线程环境下，由于每个线程都有自己的本地内存，线程之间对共享变量的修改不一定能够及时同步到主内存和其他线程的本地内存中。可见性保证了共享变量的修改对其他线程是可见的，即能够正确读取到最新的值。")]),t._v(" "),a("li",[t._v("有序性（Ordering） ：是指程序执行的顺序与代码的顺序一致。在多线程环境下，由于指令重排序和编译器优化的存在，代码的执行顺序可能与代码的编写顺序不一致。有序性保证了程序的执行顺序与代码的顺序一致，即保证了代码的串行语义。")])]),t._v(" "),a("p",[t._v("为了保证原子性、可见性和有序性，我们可以使用同步机制（如锁、volatile关键字、synchronized关键字等）来控制线程的访问和操作。")]),t._v(" "),a("h3",{attrs:{id:"分析下面几行代码的原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分析下面几行代码的原子性"}},[t._v("#")]),t._v(" 分析下面几行代码的原子性？")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ni"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ni "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("ul",[a("li",[t._v("第1句是基本类型赋值，是原子性操作。")]),t._v(" "),a("li",[t._v("第2句先读i的值，再赋值到j，两步操作，不能保证原子性。")]),t._v(" "),a("li",[t._v("第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。")])]),t._v(" "),a("h3",{attrs:{id:"原子性、可见性、有序性都应该怎么保证呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原子性、可见性、有序性都应该怎么保证呢"}},[t._v("#")]),t._v(" 原子性、可见性、有序性都应该怎么保证呢？")]),t._v(" "),a("ul",[a("li",[t._v("原子性：使用同步机制，如synchronized关键字、Lock接口、Atomic类等，来控制对共享变量的访问和操作，确保操作是不可分割的。")]),t._v(" "),a("li",[t._v("可见性：Java使用volatile关键字或者同步机制，如synchronized关键字、Lock接口等，来保证对共享变量的修改对其他线程是可见的。")]),t._v(" "),a("li",[t._v("有序性：使用volatile关键字或者同步机制，如synchronized关键字、Lock接口等，来保证程序执行的顺序与代码的顺序一致。")])]),t._v(" "),a("h2",{attrs:{id:"说说什么是指令重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说什么是指令重排"}},[t._v("#")]),t._v(" 说说什么是指令重排？")]),t._v(" "),a("p",[t._v("指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。但并不是说指令任意重排，处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果。")]),t._v(" "),a("p",[t._v("譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排——(A+10)x2与Ax2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证处理器执行后面依赖到A、B值的操作时能获取正确的A和B值即可。")]),t._v(" "),a("p",[t._v("在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("编译器优化的重排序")]),t._v("。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。")]),t._v(" "),a("li",[a("code",[t._v("指令级并行的重排序")]),t._v("。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。")]),t._v(" "),a("li",[a("code",[t._v("内存系统的重排序")]),t._v("。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。")])]),t._v(" "),a("p",[t._v("从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240316195753593.png",alt:"image-20240316195753593"}})]),t._v(" "),a("p",[t._v("我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子， Singletoninstance=new Singleton()； 对应的JVM指令分为三步："),a("code",[t._v("分配内存空间")]),t._v("--\x3e"),a("code",[t._v("初始化对象")]),t._v("---\x3e"),a("code",[t._v("对象指向分配的内存空间")]),t._v("，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/870107739207550.png",alt:"870107739207550"}})]),t._v(" "),a("p",[t._v("JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。")]),t._v(" "),a("h2",{attrs:{id:"指令重排有限制吗-happens-before了解吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#指令重排有限制吗-happens-before了解吗"}},[t._v("#")]),t._v(" 指令重排有限制吗？happens-before了解吗？")]),t._v(" "),a("h2",{attrs:{id:"volatile实现原理了解吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile实现原理了解吗"}},[t._v("#")]),t._v(" volatile实现原理了解吗？")]),t._v(" "),a("blockquote",[a("p",[t._v("volatile有两个作用，保证"),a("strong",[t._v("可见性")]),t._v(" 和"),a("strong",[t._v("有序性")]),t._v(" 。")])]),t._v(" "),a("h3",{attrs:{id:"volatile怎么保证可见性的呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile怎么保证可见性的呢"}},[t._v("#")]),t._v(" volatile怎么保证可见性的呢？")]),t._v(" "),a("p",[t._v("关于volatile变量的可见性，经常会被开发人员误解，他们会误以为下面的描述是正确的：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反映到其他线程之中。换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的”。这句话的论据部分并没有错，但是由其论据并不能得出“基于volatile变量的运算在并发下是线程安全的”这样的结论。"),a("strong",[t._v("volatile变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题）")]),t._v("，"),a("code",[t._v("但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。")])]),t._v(" "),a("p",[t._v("我们可以通过一段简单的演示来说明原因：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VolatileTest")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" race "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("increase")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        race"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("THREADS_COUNT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" threads "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("THREADS_COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("THREADS_COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            threads"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runnable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("increase")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            threads"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("start")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 等待所有累加线程都结束")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("activeCount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("race"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br"),a("span",{staticClass:"line-number"},[t._v("20")]),a("br"),a("span",{staticClass:"line-number"},[t._v("21")]),a("br"),a("span",{staticClass:"line-number"},[t._v("22")]),a("br"),a("span",{staticClass:"line-number"},[t._v("23")]),a("br"),a("span",{staticClass:"line-number"},[t._v("24")]),a("br"),a("span",{staticClass:"line-number"},[t._v("25")]),a("br"),a("span",{staticClass:"line-number"},[t._v("26")]),a("br"),a("span",{staticClass:"line-number"},[t._v("27")]),a("br"),a("span",{staticClass:"line-number"},[t._v("28")]),a("br")])]),a("p",[t._v("这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。我们运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。这是为什么呢？")]),t._v(" "),a("p",[t._v("问题就出在自增运算"),a("code",[t._v("race++")]),t._v("之中，我们用Javap反编译这段代码后会得到VolatileTest的字节码清单，发现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上已经很容易分析出并发失败的原因了："),a("strong",[t._v("当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。")])]),t._v(" "),a("p",[a("strong",[t._v("VolatileTest的字节码")])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" getstatic #"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("juc"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VolatileTest")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("race"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" iconst_1\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" iadd\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" putstatic #"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("juc"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VolatileTest")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("race"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：")]),t._v(" "),a("ul",[a("li",[t._v("运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。")]),t._v(" "),a("li",[t._v("变量不需要与其他的状态变量共同参与不变约束。")])]),t._v(" "),a("p",[t._v("相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。")]),t._v(" "),a("p",[t._v("volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。")]),t._v(" "),a("p",[t._v("例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/634309447969628.png",alt:"634309447969628"}})]),t._v(" "),a("h3",{attrs:{id:"volatile怎么保证有序性的呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile怎么保证有序性的呢"}},[t._v("#")]),t._v(" volatile怎么保证有序性的呢？")]),t._v(" "),a("p",[t._v("重排序可以分为"),a("code",[t._v("编译器重排序")]),t._v("和"),a("code",[t._v("处理器重排序")]),t._v("，valatile保证有序性，就是通过分别限制这两种类型的重排序。")]),t._v(" "),a("p",[t._v("为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入"),a("code",[t._v("内存屏障")]),t._v("来禁止特定类型的处理器重排序。指的是重排序时不能把后面的指令重排序到内存屏障之前的位置。")]),t._v(" "),a("p",[a("strong",[t._v("什么是内存屏障")])]),t._v(" "),a("p",[t._v("内存屏障其实就是一个CPU指令，在硬件层面上来说可以分为两种："),a("code",[t._v("Load Barrier")]),t._v(" 和 "),a("code",[t._v("Store Barrier")]),t._v("即读屏障和写屏障。主要有两个作用：")]),t._v(" "),a("p",[t._v("（1）阻止屏障两侧的指令重排序；")]),t._v(" "),a("p",[t._v("（2）强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。")]),t._v(" "),a("p",[t._v("在JVM层面上来说作用与上面的一样，但是种类可以分为四种：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("屏障类型")]),t._v(" "),a("th",[t._v("示例")]),t._v(" "),a("th",[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("LoadLoad")]),t._v(" "),a("td",[t._v("Load1;"),a("br"),t._v("LoadLoad;"),a("br"),t._v("Load2;")]),t._v(" "),a("td",[t._v("保证load1的读操作先于load2执行")])]),t._v(" "),a("tr",[a("td",[t._v("StoreStore")]),t._v(" "),a("td",[t._v("Store1;"),a("br"),t._v("StoreStore;"),a("br"),t._v("Store2;")]),t._v(" "),a("td",[t._v("保证store1的写操作先于store2执行,并刷新到主内存")])]),t._v(" "),a("tr",[a("td",[t._v("LoadStore")]),t._v(" "),a("td",[t._v("Load1;"),a("br"),t._v("LoadStore;"),a("br"),t._v("Store2;")]),t._v(" "),a("td",[t._v("保证load1的读操作结束先于load2的写操作执行")])]),t._v(" "),a("tr",[a("td",[t._v("StoreLoad")]),t._v(" "),a("td",[t._v("Store1;"),a("br"),t._v("StoreLoad;"),a("br"),t._v("Load2;")]),t._v(" "),a("td",[t._v("保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行")])])])]),t._v(" "),a("ol",[a("li",[t._v("在每个volatile写操作的前面插入一个 StoreStore 屏障")]),t._v(" "),a("li",[t._v("在每个volatile写操作的后面插入一个 StoreLoad 屏障")]),t._v(" "),a("li",[t._v("在每个volatile读操作的后面插入一个 LoadLoad 屏障")]),t._v(" "),a("li",[t._v("在每个volatile读操作的后面插入一个 LoadStore 屏障")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/123213213213123.png",alt:"123213213213123"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/213213432423456.png",alt:"213213432423456"}})])])}),[],!1,null,null,null);a.default=e.exports}}]);
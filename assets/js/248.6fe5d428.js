(window.webpackJsonp=window.webpackJsonp||[]).push([[248],{577:function(t,v,_){"use strict";_.r(v);var e=_(8),r=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"缓存设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存设计"}},[t._v("#")]),t._v(" 缓存设计")]),t._v(" "),v("h2",{attrs:{id:"什么是缓存击穿、缓存穿透、缓存雪崩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存击穿、缓存穿透、缓存雪崩"}},[t._v("#")]),t._v(" 什么是缓存击穿、缓存穿透、缓存雪崩？")]),t._v(" "),v("h3",{attrs:{id:"缓存击穿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[t._v("#")]),t._v(" 缓存击穿")]),t._v(" "),v("blockquote",[v("p",[t._v("一个"),v("strong",[t._v("并发访问量比较大的key")]),t._v("在"),v("strong",[t._v("某个时间过期")]),t._v("，导致所有的请求"),v("strong",[t._v("直接打在DB")]),t._v("上。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240312205105015.png",alt:"image-20240312205105015"}})]),t._v(" "),v("p",[v("strong",[t._v("缓存击穿解决方案：")])]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("加锁更新")]),t._v("，比如请求查询A，发现缓存中没有，对A这个key加互斥锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240312205049240.png",alt:"image-20240312205049240"}})])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("设置key永不过期")]),t._v("（update的情况下删除缓存）")])])]),t._v(" "),v("h3",{attrs:{id:"缓存穿透"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[t._v("#")]),t._v(" 缓存穿透")]),t._v(" "),v("blockquote",[v("p",[t._v("用户想要查询一个数据，发现"),v("strong",[t._v("redis中没有也就是缓存没有命中")]),t._v("，"),v("strong",[t._v("于是向持久层数据库查询。发现也没有")]),t._v("，于是本次查询失败。当高并发时，缓存都没有命中，于是都去请求数据库。这会给数据库造成很大的压力，甚至宕机，这时候就叫做出现了"),v("strong",[t._v("缓存穿透")]),t._v("。")]),t._v(" "),v("p",[v("strong",[t._v("注意")]),t._v("：redis和数据库中都没有这个数据")])]),t._v(" "),v("p",[t._v("缓存穿透可能有两种原因：")]),t._v(" "),v("ol",[v("li",[t._v("自身业务代码问题")]),t._v(" "),v("li",[t._v("恶意攻击，爬虫造成空命中")])]),t._v(" "),v("p",[v("strong",[t._v("缓存穿透解决方案：")])]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("缓存空值/默认值")]),t._v("：一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/88155956565.png",alt:"88155956565"}})]),t._v(" "),v("p",[v("strong",[t._v("缓存空值有两大问题：")])]),t._v(" "),v("ol",[v("li",[t._v("空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。")]),t._v(" "),v("li",[t._v("缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("布隆过滤器")]),t._v("\n除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/87895223232.png",alt:"87895223232"}})]),t._v(" "),v("p",[t._v("布隆过滤器里会保存数据是否存在，如果判断数据不在，就不会访问存储。")]),t._v(" "),v("p",[v("strong",[t._v("布隆过滤器不能做到100%判断正确，这个可以设置因子来决定。就是说有可能10000次里面会出现300次错误。它通过这种方式提高了性能，我们的目的是不能让过多的请求打到数据库上。少量打入是可以被允许的。")])])])]),t._v(" "),v("p",[t._v("在java里面，可以使用guava或者hutool里面的工具类，工具类中都有对应的布隆过滤器的实现。")]),t._v(" "),v("p",[t._v("两种解决方案的对比：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("解决缓存穿透")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("适用场景")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("维护成本")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("缓存空对象")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("数据命中不高"),v("br"),t._v("数据频繁实时性高")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("代码维护简单"),v("br"),t._v("需要较多的缓存空间"),v("br"),t._v("数据不一致")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("布隆过滤器")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("数据命中不高"),v("br"),t._v("数据相对固定实时性低")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("代码维护复杂"),v("br"),t._v("缓存空间占用少")])])])]),t._v(" "),v("h3",{attrs:{id:"缓存雪崩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[t._v("#")]),t._v(" 缓存雪崩")]),t._v(" "),v("p",[v("strong",[t._v("某⼀时刻发生大规模的缓存失效的情况")]),t._v("，例如"),v("strong",[t._v("缓存服务宕机")]),t._v("、"),v("strong",[t._v("大量key在同一时间过期")]),t._v("，这样的后果就是⼤量的请求进来直接打到DB上，可能导致整个系统的崩溃，称为雪崩。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/8989999962565.png",alt:"8989999962565"}})]),t._v(" "),v("p",[v("strong",[t._v("缓存雪崩解决方案")])]),t._v(" "),v("ol",[v("li",[t._v("redis高可用（"),v("strong",[t._v("集群")]),t._v(")，通过集群来提升缓存的可用性")]),t._v(" "),v("li",[v("strong",[t._v("加随机因子")]),t._v("(根据数据冷热程度)\n"),v("ul",[v("li",[t._v("为了避免大量的缓存在同一时间过期，"),v("strong",[t._v("可以把不同的 key 过期时间随机生成，避免过期时间太过集中")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("热点数据永不过期")]),t._v("。")])])]),t._v(" "),v("li",[v("strong",[t._v("限流降级")]),t._v("（已经发生雪崩的情况下，系统架构级别策略)\n"),v("ul",[v("li",[v("strong",[t._v("服务熔断")]),t._v("：当缓存服务器宕机或超时响应时，为了防止整个系统出现雪崩，"),v("strong",[t._v("暂时停止业务服务访问缓存系统")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("服务降级")]),t._v("：当出现大量缓存失效，而且处在高并发高负荷的情况下，"),v("strong",[t._v("在业务系统内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。")])])])])]),t._v(" "),v("h2",{attrs:{id:"说说布隆过滤器吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#说说布隆过滤器吗"}},[t._v("#")]),t._v(" 说说布隆过滤器吗？")]),t._v(" "),v("p",[t._v("布隆过滤器，它是一个连续的数据结构，每个存储位存储都是一个 bit ，即 0 或者1 , 来标识数据是否存在。")]),t._v(" "),v("p",[t._v("存储数据的时时候，使用K个不同的哈希函数将这个变量映射为bit列表的的K个点，把它们置为1")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240312214858712.png",alt:"image-20240312214858712"}})]),t._v(" "),v("p",[t._v("我们判断缓存key是否存在，同样，K个哈希函数，映射到bit列表上的K个点，判断是不是1：")]),t._v(" "),v("ul",[v("li",[t._v("如果全不是1，那么key不存在；")]),t._v(" "),v("li",[t._v("如果都是1，也只是表示key可能存在。")])]),t._v(" "),v("p",[v("strong",[t._v("布隆过滤器也有一些缺点：")])]),t._v(" "),v("ol",[v("li",[t._v("它在判断元素是否在集合中时是有一定错误几率，因为哈希算法有一定的碰撞的概率。")]),t._v(" "),v("li",[t._v("不支持删除元素。")])]),t._v(" "),v("h2",{attrs:{id:"如何保证缓存和数据库数据的一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何保证缓存和数据库数据的一致性"}},[t._v("#")]),t._v(" 如何保证缓存和数据库数据的⼀致性？")]),t._v(" "),v("p",[t._v("根据CAP理论，在保证可用性和分区容错性的前提下，无法保证一致性，"),v("strong",[t._v("所以缓存和数据库的绝对一致是不可能实现的，只能尽可能保存缓存和数据库的最终一致性。")])]),t._v(" "),v("h3",{attrs:{id:"选择合适的缓存更新策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#选择合适的缓存更新策略"}},[t._v("#")]),t._v(" 选择合适的缓存更新策略")]),t._v(" "),v("p",[t._v("1、"),v("strong",[t._v("删除缓存而不是更新缓存")])]),t._v(" "),v("p",[t._v("当一个线程对缓存的key进行写操作的时候，如果其它线程进来读数据库的时候，读到的就是脏数据，产生了数据不一致问题。")]),t._v(" "),v("p",[t._v("相比较而言，删除缓存的速度比更新缓存的速度快很多，所用时间相对也少很多，读脏数据的概率也小很多。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/95235956265959.png",alt:"95235956265959"}})]),t._v(" "),v("p",[t._v("2、"),v("strong",[t._v("先更数据，后删缓存")])]),t._v(" "),v("p",[t._v("先更数据库还是先删缓存？")]),t._v(" "),v("p",[t._v("更新数据，耗时可能在删除缓存的百倍以上。在缓存中不存在对应的key，数据库又没有完成更新的时候，如果有线程进来读取数据，并写入到缓存，那么在更新成功之后，这个key就是一个脏数据。")]),t._v(" "),v("p",[t._v("毫无疑问，先删缓存，再更数据库，缓存中key不存在的时间的时间更长，有更大的概率会产生脏数据。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/9892626521.png",alt:"9892626521"}})]),t._v(" "),v("p",[v("strong",[t._v("目前最流行的缓存读写策略cache-aside-pattern就是采用先更数据库，再删缓存的方式。")])]),t._v(" "),v("h3",{attrs:{id:"缓存不一致处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存不一致处理"}},[t._v("#")]),t._v(" 缓存不一致处理")]),t._v(" "),v("p",[t._v("如果不是并发特别高，对缓存依赖性很强，其实一定程序的不一致是可以接受的。")]),t._v(" "),v("p",[t._v("但是如果对一致性要求比较高，那就得想办法保证缓存和数据库中数据一致。")]),t._v(" "),v("p",[t._v("缓存和数据库数据不一致常见的两种原因：")]),t._v(" "),v("ul",[v("li",[t._v("缓存key删除失败")]),t._v(" "),v("li",[t._v("并发导致写入了脏数据")])])])}),[],!1,null,null,null);v.default=r.exports}}]);
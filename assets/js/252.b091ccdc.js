(window.webpackJsonp=window.webpackJsonp||[]).push([[252],{581:function(t,e,v){"use strict";v.r(e);var _=v(8),a=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),e("h2",{attrs:{id:"为什么要使用消息队列呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用消息队列呢"}},[t._v("#")]),t._v(" 为什么要使用消息队列呢？")]),t._v(" "),e("p",[t._v("消息队列主要有三大用途，拿电商系统的下单举例：")]),t._v(" "),e("p",[e("strong",[t._v("解耦")]),t._v(" ：引入消息队列之前，下单完成之后，需要订单服务去调用库存服务减库存，调用营销服务加营销数据……引入消息队列之后，可以把订单完成的消息丢进队列里，下游服务自己去调用就行了，这样就完成了订单服务和其它服务的解耦合。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/700166559020887.png",alt:"700166559020887"}})]),t._v(" "),e("p",[e("strong",[t._v("异步")]),t._v(" ：订单支付之后，我们要扣减库存、增加积分、发送消息等等，这样一来这个链路就长了，链路一长，响应时间就变长了。引入消息队列，除了 "),e("strong",[t._v("更新订单状态")]),t._v(" ，其它的都可以"),e("strong",[t._v("异步")]),t._v("去做，这样一来就来，就能降低响应时间。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240327195817341.png",alt:"image-20240327195817341"}})]),t._v(" "),e("p",[e("strong",[t._v("削峰")]),t._v(" ：消息队列合一用来削峰，例如秒杀系统，平时流量很低，但是要做秒杀活动，秒杀的时候流量疯狂怼进来，我们的服务器，Redis，MySQL各自的承受能力都不一样，直接全部流量照单全收肯定有问题啊，严重点可能直接打挂了。我们可以把请求扔到队列里面，只放出我们服务能处理的流量，这样就能抗住短时间的大流量了。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/800928425645677.png",alt:"800928425645677"}})]),t._v(" "),e("p",[t._v("解耦、异步、削峰，是消息队列最主要的三大作用。")]),t._v(" "),e("h2",{attrs:{id:"如何进行产品选型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何进行产品选型"}},[t._v("#")]),t._v(" 如何进行产品选型")]),t._v(" "),e("p",[t._v("选择中间件的可以从这些维度来考虑：可靠性，性能，功能，可运维行，可拓展性，社区活跃度。目前常用的几个中间件，ActiveMQ作为“老古董”，市面上用的已经不多，其它几种：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("中间件")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("优点")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("缺点")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("RabbitMQ")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("轻量，迅捷，容易部署和使用，拥有灵活的路由配置")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("性能和吞吐量不太理想，不易进行二次开发")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("RocketMQ")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("性能好，高吞吐量，稳定可靠，有活跃的中文社区")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("兼容性上不是太好（"),e("strong",[t._v("有社区版和商业版")]),t._v("）")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Kafka")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("拥有强大的性能及吞吐量，兼容性很好")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("由于“攒一波再处理”导致延迟比较高")])])])]),t._v(" "),e("p",[t._v("我们的系统是面向用户的B端系统，并发量不是很高，所以选择了RabbitMQ 。")]),t._v(" "),e("p",[t._v("至于kafka，是因为需要对接设备的报警、实时数据，数据量大，在业界中一般大数据都用的kakfa，是业界的标准。")]),t._v(" "),e("h2",{attrs:{id:"rabbitmq-架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-架构"}},[t._v("#")]),t._v(" RabbitMQ 架构")]),t._v(" "),e("p",[t._v("RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。")]),t._v(" "),e("p",[t._v("AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/image-20240318201415129.png",alt:"image-20240318201415129"}})]),t._v(" "),e("p",[e("strong",[t._v("1、Message（消息）")])]),t._v(" "),e("p",[t._v("消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（传输模式，指出该消息可能需要持久化存储）等。")]),t._v(" "),e("p",[e("strong",[t._v("2、Publisher")])]),t._v(" "),e("p",[t._v("消息生产者，也是一个向交换器发布消息的客户端应用程序，就是投递消息的程序。")]),t._v(" "),e("p",[e("strong",[t._v("3、Exchange")])]),t._v(" "),e("p",[t._v("交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。消息交换机，它指定消息按什么规则，路由到哪个队列。")]),t._v(" "),e("p",[e("strong",[t._v("4、Routing Key")])]),t._v(" "),e("p",[t._v("路由关键字，exchange根据这个关键字进行消息投递。")]),t._v(" "),e("p",[e("strong",[t._v("5、Binding（绑定）")])]),t._v(" "),e("p",[t._v("用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。")]),t._v(" "),e("p",[t._v("它的作用就是把exchange和queue按照路由规则绑定起来。绑定其实就是关联了exchange和queue。")]),t._v(" "),e("p",[e("strong",[t._v("6、Queue（消息队列）")])]),t._v(" "),e("p",[t._v("消息的载体，每个消息都会被投到一个或多个队列，等待消费者连接到这个队列将其取走。它是消息的容器，也是消息的终点。")]),t._v(" "),e("p",[e("strong",[t._v("7、Connection")])]),t._v(" "),e("p",[t._v("网络连接，例如一个TCP连接。")]),t._v(" "),e("p",[e("strong",[t._v("8、Channel（信道，通道）")])]),t._v(" "),e("p",[t._v("消息通道，在客户端的每个连接里，可建立多个channel。")]),t._v(" "),e("p",[t._v("多路复用连接中的一条独立双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念以达到复用一条TCP连接的目的。")]),t._v(" "),e("p",[e("strong",[t._v("9、Consumer")])]),t._v(" "),e("p",[t._v("消息消费者，表示一个从消息队列中取得消息的客户端应用程序，就是接受消息的程序。")]),t._v(" "),e("p",[e("strong",[t._v("10、Virtual Host")])]),t._v(" "),e("p",[t._v("虚拟主机，表示一批交换器、消息队列和相关对象。"),e("strong",[t._v("一个broker里可以有多个vhost，用作不同用户的权限分离")]),t._v("。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。"),e("strong",[t._v("每个vhost本质上就是一个mini版的rabbitmq服务器，拥有自己的队列、交换器、绑定和权限机制。")])]),t._v(" "),e("p",[t._v("vhost是AMQP概念的基础，必须在连接时指定，rabbitmq默认的vhost是 / 。")]),t._v(" "),e("p",[e("strong",[t._v("11、Broker")])]),t._v(" "),e("p",[t._v("表示消息队列服务器实体。它提供一种传输服务，它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输。")]),t._v(" "),e("h2",{attrs:{id:"如何保证rabbitmq不被重复消费"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何保证rabbitmq不被重复消费"}},[t._v("#")]),t._v(" 如何保证RabbitMQ不被重复消费？")]),t._v(" "),e("blockquote",[e("p",[t._v("对分布式消息队列来说，同时做到确保一定投递和不重复投递是很难的！！！")])]),t._v(" "),e("h3",{attrs:{id:"消息重复的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息重复的原因"}},[t._v("#")]),t._v(" 消息重复的原因")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("生产者")]),t._v("：生产者可能会重复推送一条数据到 MQ 中，比如 Controller 接口被"),e("strong",[t._v("重复调用了 2 次")]),t._v("，没有做接口幂等性导致的；")]),t._v(" "),e("li",[e("strong",[t._v("MQ")]),t._v("：在消费者消费完准备响应 ack 消息消费成功时，MQ 突然挂了，导致 MQ 以为消费者还未消费该条数据，MQ 恢复后再次推送了该条消息，导致了重复消费。")]),t._v(" "),e("li",[e("strong",[t._v("消费者")]),t._v("：消费者已经消费完消息，正准备但是还未响应给ack消息到时，此时消费者挂了，服务重启后 MQ 以为消费者还没有消费该消息，再次推送了该条消息。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/fc22decb6ed8b3ab54810e5b7ae90fa0.jpeg",alt:"img"}})]),t._v(" "),e("blockquote",[e("p",[t._v("处理消息重复问题，主要有业务端自己保证，主要的方式有两种：业务幂等 和消息去重 。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/bd4c1626adb9eddd49086b9c86f2e50d.jpeg",alt:"img"}})]),t._v(" "),e("p",[t._v("缺点：如果说第一次消息投递异常没有消费成功，并且没有将消息状态给置为成功或者没有删除消息表记录，此时延时消费每次执行下列都是一直处于消费中，最后消费就会被视为消费失败而被投递到死信Topic中")]),t._v(" "),e("p",[t._v("方案：插入的消息表必须要带一个最长消费过期时间，例如10分钟")]),t._v(" "),e("ul",[e("li",[t._v("缺点：时间到了，也有可能会被重复消费。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/studentgitee/note-picture/raw/master/32c346a816efafc5802aae6beeb77e08.jpeg",alt:"img"}})]),t._v(" "),e("ul",[e("li",[t._v("上述方案只需要一个存储的中心媒介，那我们可以选择更灵活的存储中心媒介，比如Redis。使用Redis有两个好处：\n"),e("ul",[e("li",[t._v("性能上损耗更低")]),t._v(" "),e("li",[t._v("上面我们讲到的超时时间可以直接利用Redis本身的ttl实现")])])])]),t._v(" "),e("p",[t._v("比较好的方案是：")]),t._v(" "),e("p",[t._v("在去重表中加上执行次数，当执行次数累计达到预订次数，则进行异常记录，为人工干预提供异常记录（"),e("strong",[t._v("补偿机制")]),t._v("），来手动处理，并不再执行消费流程")]),t._v(" "),e("h2",{attrs:{id:"如何保证rabbitmq消息的顺序性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何保证rabbitmq消息的顺序性"}},[t._v("#")]),t._v(" 如何保证RabbitMQ消息的顺序性？")]),t._v(" "),e("h2",{attrs:{id:"如何保证rabbitmq消息的可靠传输"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何保证rabbitmq消息的可靠传输"}},[t._v("#")]),t._v(" 如何保证RabbitMQ消息的可靠传输？")])])}),[],!1,null,null,null);e.default=a.exports}}]);
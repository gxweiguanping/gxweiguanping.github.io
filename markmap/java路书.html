<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.4/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.15.4/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.4/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:M,mm:ge}=window,me=new M.Toolbar;me.attach(ge);const fe=me.render();fe.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(fe)})})()</script><script>((F,I,R,H)=>{const X=F();window.mm=X.Markmap.create("svg#mindmap",(I||X.deriveOptions)(H),R)})(()=>window.markmap,null,{"type":"heading","depth":0,"payload":{"lines":[0,1]},"content":"后端开发技术栈","children":[{"type":"heading","depth":1,"payload":{"lines":[2,3]},"content":"java","children":[{"type":"heading","depth":2,"payload":{"lines":[4,5]},"content":"面向对象","children":[{"type":"list_item","depth":3,"payload":{"lines":[6,7]},"content":"封装","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[8,9]},"content":"继承","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[10,11]},"content":"多态","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[12,13]},"content":"抽象类","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[14,15]},"content":"接口","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[16,17]},"content":"重载、重写","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[18,19]},"content":"基本数据类型","children":[{"type":"list_item","depth":4,"payload":{"lines":[20,21]},"content":"byte 1字节","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[22,23]},"content":"short 2字节","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[24,25]},"content":"int 4字节","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[26,27]},"content":"long 8字节","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[28,29]},"content":"float 8字节","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[30,31]},"content":"double 4字节","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[32,33]},"content":"char 2字节","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[34,35]},"content":"boolean 4字节","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[36,37]},"content":"jdk常用类","children":[{"type":"list_item","depth":3,"payload":{"lines":[38,39]},"content":"String","children":[{"type":"list_item","depth":4,"payload":{"lines":[40,41]},"content":"不可变的字符序列","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[42,43]},"content":"String对象的字符内容是存储在一个字符数组char value[]中的","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[44,45]},"content":"StringBuild","children":[{"type":"list_item","depth":4,"payload":{"lines":[46,47]},"content":"可变字符序列","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[48,49]},"content":"线程不安全","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[50,51]},"content":"效率高","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[52,53]},"content":"StringBuffer","children":[{"type":"list_item","depth":4,"payload":{"lines":[54,55]},"content":"可变字符序列","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[56,57]},"content":"线程安全","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[58,59]},"content":"效率低","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[60,61]},"content":"日期时间API","children":[{"type":"list_item","depth":4,"payload":{"lines":[62,63]},"content":"System  jdk8之前","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[64,65]},"content":"Date jdk8之前","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[66,67]},"content":"SimpleDateFormat jdk8之前","children":[{"type":"list_item","depth":5,"payload":{"lines":[68,69]},"content":"线程不安全","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[70,71]},"content":"Calendar jdk8之前","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[72,73]},"content":"LocalDate","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[74,75]},"content":"LocalTime","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[76,77]},"content":"LocalDateTime","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[78,79]},"content":"包装类","children":[{"type":"list_item","depth":4,"payload":{"lines":[80,81]},"content":"Byte","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[82,83]},"content":"Short","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[84,85]},"content":"Integer","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[86,87]},"content":"Long","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[88,89]},"content":"Float","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[90,91]},"content":"Double","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[92,93]},"content":"Character","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[94,95]},"content":"Boolean","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[96,97]},"content":"java比较器","children":[{"type":"list_item","depth":4,"payload":{"lines":[98,99]},"content":"Comparable","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[100,101]},"content":"Comparator","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[102,103]},"content":"BigInteger","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[104,105]},"content":"BigDecimal","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[106,107]},"content":"数据结构","children":[{"type":"list_item","depth":3,"payload":{"lines":[108,109]},"content":"数组","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[110,111]},"content":"枚举enum","children":[{"type":"list_item","depth":4,"payload":{"lines":[112,113]},"content":"当需要定义一组常量时，强烈建议使用枚举类","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[114,115]},"content":"集合","children":[{"type":"list_item","depth":4,"payload":{"lines":[116,117]},"content":"集合工具类","children":[{"type":"list_item","depth":5,"payload":{"lines":[118,119]},"content":"Collections","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[120,121]},"content":"Collection","children":[{"type":"list_item","depth":5,"payload":{"lines":[122,123]},"content":"List","children":[{"type":"list_item","depth":6,"payload":{"lines":[124,125]},"content":"ArrayList基于数组动态扩容","children":[{"type":"list_item","depth":7,"payload":{"lines":[126,127]},"content":"JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[128,129]},"content":"JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[130,131]},"content":"1.5倍扩容","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[132,133]},"content":"线程不安全","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[134,135]},"content":"LinkedList基于链表动态扩容","children":[{"type":"list_item","depth":7,"payload":{"lines":[136,137]},"content":"双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[138,139]},"content":"线程不安全","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[140,141]},"content":"Vector","children":[{"type":"list_item","depth":7,"payload":{"lines":[142,143]},"content":"线程安全","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[144,145]},"content":"2倍扩容","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[146,147]},"content":"元素有序、可重复的集合","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[148,149]},"content":"Set","children":[{"type":"list_item","depth":6,"payload":{"lines":[150,151]},"content":"HsahSet 不能重复且无序","children":[{"type":"list_item","depth":7,"payload":{"lines":[152,153]},"content":"两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[154,155]},"content":"hashCode相等时，equals不一定相等的","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[156,157]},"content":"相等的对象必须具有相等的散列码","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[158,159]},"content":"底层就是基于 HashMap 实现","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[160,161]},"content":"TreeSet 不能重复且有序","children":[{"type":"list_item","depth":7,"payload":{"lines":[162,163]},"content":"底层使用红黑树结构存储数据","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[164,165]},"content":"自然排序和定制排序","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[166,167]},"content":"元素无序、不可重复的集合","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[168,169]},"content":"判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[170,171]},"content":"Map","children":[{"type":"list_item","depth":5,"payload":{"lines":[172,173]},"content":"HashMap 线程不安全","children":[{"type":"list_item","depth":6,"payload":{"lines":[174,175]},"content":"底层数据结构","children":[{"type":"list_item","depth":7,"payload":{"lines":[176,177]},"content":"JDK1.7  数组+链表","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[178,179]},"content":"JDK1.8  数组+链表+红黑树","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[180,181]},"content":"性质","children":[{"type":"list_item","depth":7,"payload":{"lines":[182,183]},"content":"key值不能重复,value可以重复","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[184,185]},"content":"如果使用个对象来当做map的key,须重写hashCode()和equals()方法","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[186,187]},"content":"允许使用null键和null值","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[188,189]},"content":"put方法流程","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[192,193]},"content":"Hashtable 线程安全","children":[{"type":"list_item","depth":6,"payload":{"lines":[194,195]},"content":"不允许使用 null 作为 key 和 value","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[196,197]},"content":"使⽤ synchronized 来保证线程安全","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[198,199]},"content":"TreeMap","children":[{"type":"list_item","depth":6,"payload":{"lines":[200,201]},"content":"底层使用红黑树结构存储数据","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[202,203]},"content":"ConcurrentHashMap 线程安全","children":[{"type":"list_item","depth":6,"payload":{"lines":[204,205]},"content":"底层数据结构","children":[{"type":"list_item","depth":7,"payload":{"lines":[206,207]},"content":"JDK1.7 的 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[208,209]},"content":"JDK1.8采⽤的数据结构跟 HashMap1.8 的结构⼀样","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[210,211]},"content":"实现线程安全的⽅式","children":[{"type":"list_item","depth":7,"payload":{"lines":[212,213]},"content":"在 JDK1.7 的时候， ConcurrentHashMap （分段锁）对整个桶数组进⾏了分割分段( Segment )，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[214,215]},"content":"JDK1.8之后，并发控制使⽤ synchronized 和 CAS 来操作","children":[]}]}]},{"type":"list_item","depth":5,"payload":{"lines":[216,217]},"content":"LinkHashMap","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[218,219]},"content":"Iterator","children":[{"type":"list_item","depth":5,"payload":{"lines":[220,221]},"content":"概述","children":[{"type":"list_item","depth":6,"payload":{"lines":[222,223]},"content":"是可以遍历集合的对象","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[224,225]},"content":"foreach","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[226,227]},"content":"使用iterator可以remove元素","children":[{"type":"list_item","depth":6,"payload":{"lines":[228,229]},"content":"迭代器的remove方法是删除上次调用next方法时返回的元素","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[230,231]},"content":"Arraylist的remove方法改变了原来的索引，从而出现了并发错误","children":[]}]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[232,233]},"content":"异常","children":[{"type":"list_item","depth":3,"payload":{"lines":[234,235]},"content":"Error","children":[{"type":"list_item","depth":4,"payload":{"lines":[236,238]},"content":"定义了在通常环境下不希望被程序捕获的异常。Error 类型的异常用于 Java 运行时由系统显示与运行时系统本身有关的错误。<br>\n堆栈溢出是这种错误的一例。","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[239,240]},"content":"Exection","children":[{"type":"list_item","depth":4,"payload":{"lines":[241,242]},"content":"编译时异常（受查异常）","children":[{"type":"list_item","depth":5,"payload":{"lines":[243,244]},"content":"IOException","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[245,246]},"content":"ClassNotFoundExcetion","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[247,248]},"content":"SQLException","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[249,250]},"content":"运行时异常（非受查异常）RuntimeException","children":[{"type":"list_item","depth":5,"payload":{"lines":[251,252]},"content":"ClassCastException","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[253,254]},"content":"IndexOutOfBoundsExcetion","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[255,256]},"content":"NullPointerException","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[257,258]},"content":"ArrayIndexOutOfBoundsException","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[259,260]},"content":"自定义异常","children":[{"type":"list_item","depth":5,"payload":{"lines":[261,262]},"content":"在实际开发中所遇到的一些异常，不能完全表示","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[263,264]},"content":"处理","children":[{"type":"list_item","depth":4,"payload":{"lines":[265,266]},"content":"throw new RuntimeException（产生一个异常）","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[267,268]},"content":"try-catch处理异常","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[269,270]},"content":"throws抛出","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[271,272]},"content":"日志","children":[{"type":"list_item","depth":3,"payload":{"lines":[273,274]},"content":"Logback","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[275,276]},"content":"Log4j2","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[277,278]},"content":"泛型","children":[{"type":"list_item","depth":3,"payload":{"lines":[279,280]},"content":"概述","children":[{"type":"list_item","depth":4,"payload":{"lines":[281,282]},"content":"所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[283,284]},"content":"泛型方法","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[285,286]},"content":"泛型类","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[287,288]},"content":"泛型接口","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[289,290]},"content":"通配符?","children":[{"type":"list_item","depth":4,"payload":{"lines":[291,292]},"content":"有限制的通配符","children":[{"type":"list_item","depth":5,"payload":{"lines":[293,294]},"content":"&lt;? extends Number&gt; 只允许泛型为Number及Number子类的引用调用","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[295,296]},"content":"&lt;? super Number&gt;  只允许泛型为Number及Number父类的引用调用","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[297,298]},"content":"&lt;? extends Comparable&gt; 只允许泛型为实现Comparable接口的实现类的引用调用","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[299,300]},"content":"泛型擦除","children":[{"type":"list_item","depth":4,"payload":{"lines":[301,302]},"content":"JVM并不知道泛型的存在，因为泛型在编译阶段就已经被处理成普通的类和方法","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[303,304]},"content":"反射","children":[{"type":"list_item","depth":3,"payload":{"lines":[305,306]},"content":"概述","children":[{"type":"list_item","depth":4,"payload":{"lines":[307,308]},"content":"Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[309,310]},"content":"实现方式","children":[{"type":"list_item","depth":4,"payload":{"lines":[311,312]},"content":"Class clazz = Class.forNmae(&quot;com.user.entery.Person&quot;)","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[313,314]},"content":"Class clazz = Person.class;","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[315,317]},"content":"Person p = new Person();<br>\nClass clazz = p.getClass();","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[318,320]},"content":"ClassLoader cl = this.getClass().getClassLoader();<br>\nClass clazz4 = cl.loadClass(“com.user.entery.Person”);","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[321,322]},"content":"运行时类的完成结构","children":[{"type":"list_item","depth":4,"payload":{"lines":[323,324]},"content":"Field、Method、Constructor、Superclass、Interface、Annotation","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[325,326]},"content":"多线程","children":[{"type":"list_item","depth":3,"payload":{"lines":[327,328]},"content":"并行和并发","children":[{"type":"list_item","depth":4,"payload":{"lines":[329,330]},"content":"并发","children":[{"type":"list_item","depth":5,"payload":{"lines":[331,332]},"content":"一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[333,334]},"content":"并行","children":[{"type":"list_item","depth":5,"payload":{"lines":[335,336]},"content":"多个CPU同时执行多个任务。比如：多个人同时做不同的事","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[337,338]},"content":"进程和线程","children":[{"type":"list_item","depth":4,"payload":{"lines":[339,340]},"content":"进程","children":[{"type":"list_item","depth":5,"payload":{"lines":[341,342]},"content":"是一个正在运行的一个程序，如：运行中的QQ，运行中的MP3播放器","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[343,344]},"content":"进程作为资源分配的单位","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[345,346]},"content":"线程","children":[{"type":"list_item","depth":5,"payload":{"lines":[347,348]},"content":"进程可进一步细化为线程","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[349,350]},"content":"线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[351,352]},"content":"线程的4种创建方式","children":[{"type":"list_item","depth":4,"payload":{"lines":[353,354]},"content":"继承Thread类","children":[{"type":"list_item","depth":5,"payload":{"lines":[355,356]},"content":"通过该Thread对象的start()方法来启动这个线程，而非直接调用run()","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[357,358]},"content":"如果直接调用run()方法，则只是普通的调用","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[359,360]},"content":"实现Runnable接口","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[361,362]},"content":"实现Callable接口（JDK5.0 新增）","children":[{"type":"list_item","depth":5,"payload":{"lines":[363,364]},"content":"能获取返回值，需要借助FutureTask类，get()方法会使所在线程阻塞，直到返回结果。","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[365,366]},"content":"Callable是支持泛型的","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[367,368]},"content":"创建线程池的方式JDK5.0 新增","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[369,370]},"content":"线程的状态转换","children":[{"type":"list_item","depth":4,"payload":{"lines":[371,372]},"content":"创建状态","children":[{"type":"list_item","depth":5,"payload":{"lines":[373,374]},"content":"当用 new 操作符创建一个线程的时候","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[375,376]},"content":"就绪状态","children":[{"type":"list_item","depth":5,"payload":{"lines":[377,378]},"content":"调用 start 方法，处于就绪状态的线程并不一定马上就会执行 run 方法，还需要等待CPU的调度","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[379,380]},"content":"运行状态","children":[{"type":"list_item","depth":5,"payload":{"lines":[381,382]},"content":"CPU 开始调度线程，并开始执行 run 方法","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[383,384]},"content":"阻塞状态","children":[{"type":"list_item","depth":5,"payload":{"lines":[385,386]},"content":"线程的执行过程中由于一些原因进入阻塞状态比如：调用 sleep 方法、尝试去得到一个锁等等","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[387,388]},"content":"死亡状态","children":[{"type":"list_item","depth":5,"payload":{"lines":[389,390]},"content":"run 方法执行完 或者 执行过程中遇到了一个异常","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[391,392]},"content":"线程之间的协作","children":[{"type":"list_item","depth":4,"payload":{"lines":[393,394]},"content":"Object类","children":[{"type":"list_item","depth":5,"payload":{"lines":[395,396]},"content":"wait","children":[{"type":"list_item","depth":6,"payload":{"lines":[397,398]},"content":"令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[399,400]},"content":"会释放锁","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[401,402]},"content":"notify","children":[{"type":"list_item","depth":6,"payload":{"lines":[403,404]},"content":"唤醒正在排队等待同步资源的线程中优先级最高者结束等待","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[405,406]},"content":"notifyAll","children":[{"type":"list_item","depth":6,"payload":{"lines":[407,408]},"content":"唤醒正在排队等待资源的所有线程结束等待.","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[409,410]},"content":"sleep","children":[{"type":"list_item","depth":5,"payload":{"lines":[411,412]},"content":"令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[413,414]},"content":"不会释放锁","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[415,416]},"content":"yield","children":[{"type":"list_item","depth":5,"payload":{"lines":[417,418]},"content":"暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[419,420]},"content":"若队列中没有同优先级的线程，忽略此方法","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[421,422]},"content":"不会释放锁","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[423,424]},"content":"join","children":[{"type":"list_item","depth":5,"payload":{"lines":[425,426]},"content":"当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[427,428]},"content":"线程池","children":[{"type":"list_item","depth":4,"payload":{"lines":[429,430]},"content":"ThreadPoolExecutor","children":[{"type":"list_item","depth":5,"payload":{"lines":[431,432]},"content":"核心参数","children":[{"type":"list_item","depth":6,"payload":{"lines":[433,434]},"content":"corePoolSize   核心线程池大小","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[435,436]},"content":"keepAliveTime 线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程有效时间","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[437,438]},"content":"maximumPoolSize   最大线程池大小","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[439,440]},"content":"TimeUnit  keepAliveTime时间单位","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[441,442]},"content":"workQueue 阻塞任务队列","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[443,444]},"content":"threadFactory 新建线程工厂","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[445,446]},"content":"RejectedExecutionHandler  当提交任务数超过maxmumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[447,448]},"content":"运行流程","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[449,450]},"content":"Executors","children":[{"type":"list_item","depth":5,"payload":{"lines":[451,452]},"content":"阿里规范禁用","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[453,454]},"content":"newCachedThreadPool()","children":[{"type":"list_item","depth":6,"payload":{"lines":[455,456]},"content":"创建一个可根据需要创建新线程的线程池","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[457,458]},"content":"newFixedThreadPool(n)","children":[{"type":"list_item","depth":6,"payload":{"lines":[459,460]},"content":"创建一个可重用固定线程数的线程池","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[461,462]},"content":"newSingleThreadExecutor()","children":[{"type":"list_item","depth":6,"payload":{"lines":[463,464]},"content":"创建一个只有一个线程的线程池","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[465,466]},"content":"newScheduledThreadPool(n)","children":[{"type":"list_item","depth":6,"payload":{"lines":[467,468]},"content":"创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[469,470]},"content":"好处","children":[{"type":"list_item","depth":5,"payload":{"lines":[471,472]},"content":"提高响应速度（减少了创建新线程的时间）","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[473,474]},"content":"降低资源消耗（重复利用线程池中线程，不需要每次都创建）","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[475,476]},"content":"便于线程管理","children":[]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[477,478]},"content":"并发编程","children":[{"type":"list_item","depth":3,"payload":{"lines":[479,480]},"content":"并发三大特性","children":[{"type":"list_item","depth":4,"payload":{"lines":[481,482]},"content":"原子性","children":[{"type":"list_item","depth":5,"payload":{"lines":[483,484]},"content":"就是指一个操作是不可中断的，要么执行成功要么执行失败，在多线程中，一个线程正在执行就不会被其他线程干扰","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[485,486]},"content":"可见性","children":[{"type":"list_item","depth":5,"payload":{"lines":[487,488]},"content":"可见性是指多个线程访问同一个变量时，其中一个线程修改了该变量的值，其它线程能够立即看到修改的值","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[489,490]},"content":"有序性","children":[{"type":"list_item","depth":5,"payload":{"lines":[491,492]},"content":"在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，但是会影响到多线程并发执行的正确性","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[493,494]},"content":"synchronized","children":[{"type":"list_item","depth":4,"payload":{"lines":[495,496]},"content":"原子性","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[497,498]},"content":"可见性","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[499,500]},"content":"有序性","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[501,502]},"content":"锁升级","children":[{"type":"list_item","depth":5,"payload":{"lines":[503,504]},"content":"Monitor对象头","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[505,506]},"content":"无锁、偏向锁、轻量级锁、重量级锁","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[507,508]},"content":"同步代码块","children":[{"type":"list_item","depth":5,"payload":{"lines":[509,510]},"content":"指定需谨慎","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[511,512]},"content":"很多时候也是指定为this或类名.class","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[513,514]},"content":"同步方法","children":[{"type":"list_item","depth":5,"payload":{"lines":[515,516]},"content":"静态方法","children":[{"type":"list_item","depth":6,"payload":{"lines":[517,518]},"content":"类名.class","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[519,520]},"content":"非静态方法","children":[{"type":"list_item","depth":6,"payload":{"lines":[521,522]},"content":"（this）","children":[]}]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[523,524]},"content":"Lock","children":[{"type":"list_item","depth":4,"payload":{"lines":[525,526]},"content":"ReentrantLock","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[527,528]},"content":"valitate 关键字","children":[{"type":"list_item","depth":4,"payload":{"lines":[529,530]},"content":"可见性","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[531,532]},"content":"有序性","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[533,534]},"content":"threadlocal","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[535,536]},"content":"CAS","children":[{"type":"list_item","depth":4,"payload":{"lines":[537,538]},"content":"概述","children":[{"type":"list_item","depth":5,"payload":{"lines":[539,540]},"content":"compare and swap的缩写，中文翻译成比较并交换。","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[541,542]},"content":"CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[543,544]},"content":"案例","children":[{"type":"list_item","depth":5,"payload":{"lines":[545,546]},"content":"AtomicInteger","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[547,548]},"content":"AQS","children":[{"type":"list_item","depth":4,"payload":{"lines":[549,550]},"content":"概述：全称是AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[551,552]},"content":"Future","children":[{"type":"list_item","depth":4,"payload":{"lines":[553,554]},"content":"FutrueTask","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[555,556]},"content":"悲观锁与乐观锁","children":[{"type":"list_item","depth":4,"payload":{"lines":[557,558]},"content":"悲观锁：每次操作都会加锁，会造成线程阻塞。","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[559,560]},"content":"乐观锁：每次操作不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，不会造成线程阻塞。","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[561,562]},"content":"Optional","children":[{"type":"list_item","depth":3,"payload":{"lines":[563,564]},"content":"为了解决空指针异常","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[565,566]},"content":"Optional.ofNullable(T t)：t可以为null","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[567,568]},"content":"T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[569,570]},"content":"lambda表达式","children":[]},{"type":"heading","depth":2,"payload":{"lines":[571,572]},"content":"Stream流","children":[]},{"type":"heading","depth":2,"payload":{"lines":[573,574]},"content":"IO流","children":[{"type":"list_item","depth":3,"payload":{"lines":[575,576]},"content":"流的分类","children":[{"type":"list_item","depth":4,"payload":{"lines":[577,578]},"content":"按操作数据单位不同分为","children":[{"type":"list_item","depth":5,"payload":{"lines":[579,580]},"content":"字节流(8 bit)","children":[{"type":"list_item","depth":6,"payload":{"lines":[581,582]},"content":"InputStream","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[583,584]},"content":"OutputStream","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[585,586]},"content":"字符流(16 bit)","children":[{"type":"list_item","depth":6,"payload":{"lines":[587,588]},"content":"Reader","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[589,590]},"content":"Writer","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[591,592]},"content":"流的流向不同分为","children":[{"type":"list_item","depth":5,"payload":{"lines":[593,594]},"content":"输入流","children":[{"type":"list_item","depth":6,"payload":{"lines":[595,596]},"content":"InputStream","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[597,598]},"content":"Reader","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[599,600]},"content":"输出流","children":[{"type":"list_item","depth":6,"payload":{"lines":[601,602]},"content":"OutputStream","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[603,604]},"content":"Writer","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[605,606]},"content":"流的角色的不同分为","children":[{"type":"list_item","depth":5,"payload":{"lines":[607,608]},"content":"节点流(文件流)","children":[{"type":"list_item","depth":6,"payload":{"lines":[609,610]},"content":"直接从数据源或目的地读写数据","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[611,612]},"content":"处理流","children":[{"type":"list_item","depth":6,"payload":{"lines":[613,614]},"content":"不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能","children":[]}]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[615,616]},"content":"缓冲流","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[617,618]},"content":"转换流","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[619,620]},"content":"注解（annotation）JDK 5.0","children":[{"type":"list_item","depth":3,"payload":{"lines":[621,622]},"content":"概述","children":[{"type":"list_item","depth":4,"payload":{"lines":[623,624]},"content":"注解其实就是代码里的特殊标记，它用于替代配置文件","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[625,626]},"content":"基本注解","children":[{"type":"list_item","depth":4,"payload":{"lines":[627,628]},"content":"@Override","children":[{"type":"list_item","depth":5,"payload":{"lines":[629,630]},"content":"检查该方法是否是重写方法","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[631,632]},"content":"@Deprecated","children":[{"type":"list_item","depth":5,"payload":{"lines":[633,634]},"content":"标记过时方法","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[635,636]},"content":"@SuppressWarnings","children":[{"type":"list_item","depth":5,"payload":{"lines":[637,638]},"content":"忽略注解中声明的警告","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[639,640]},"content":"@Functionallnterface","children":[{"type":"list_item","depth":5,"payload":{"lines":[641,643]},"content":"java8支持，表明一个函数式接口,只包含一个抽象方法的接口，<br>\n称为函数式接口","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[644,645]},"content":"JDK的元注解","children":[{"type":"list_item","depth":4,"payload":{"lines":[646,647]},"content":"@Target","children":[{"type":"list_item","depth":5,"payload":{"lines":[648,649]},"content":"用于描述注解的使用范围","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[650,651]},"content":"@Retention","children":[{"type":"list_item","depth":5,"payload":{"lines":[652,653]},"content":"用来定义该注解在哪一个级别可用","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[654,655]},"content":"在源代码中(SOURCE)、类文件中(CLASS)或者运行时(RUNTIME)","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[656,657]},"content":"@Documented","children":[{"type":"list_item","depth":5,"payload":{"lines":[658,659]},"content":"生成文档信息的时候保留注解，对类作辅助说明","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[660,661]},"content":"@Inherited","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[662,663]},"content":"@Repeatable","children":[{"type":"list_item","depth":5,"payload":{"lines":[664,665]},"content":"表示注解可以重复使用","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[666,667]},"content":"自定义注解","children":[{"type":"list_item","depth":4,"payload":{"lines":[668,669]},"content":"自定义注解+AOP","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[670,671]},"content":"自定义注解 + 拦截器","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[672,673]},"content":"jdbc","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[674,675]},"content":"数据库","children":[{"type":"heading","depth":2,"payload":{"lines":[676,677]},"content":"关系型","children":[{"type":"list_item","depth":3,"payload":{"lines":[678,679]},"content":"mysql","children":[{"type":"list_item","depth":4,"payload":{"lines":[680,681]},"content":"索引","children":[{"type":"list_item","depth":5,"payload":{"lines":[682,683]},"content":"索引失效的情况","children":[{"type":"list_item","depth":6,"payload":{"lines":[684,685]},"content":"1、最佳左前缀法则：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[686,687]},"content":"2、不等于(!= 或者&lt;&gt;)索引失效","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[688,689]},"content":"3、is null可以使用索引，is not null无法使用索引","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[690,691]},"content":"4、like以通配符%开头索引失效","children":[{"type":"list_item","depth":7,"payload":{"lines":[692,693]},"content":"如果只查id和有索引的列则会生效","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[694,695]},"content":"5、OR 前后存在非索引的列，索引失效","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[696,697]},"content":"索引分类","children":[{"type":"list_item","depth":6,"payload":{"lines":[698,699]},"content":"聚簇索引","children":[{"type":"list_item","depth":7,"payload":{"lines":[700,701]},"content":"所有的用户记录都存在了叶子节点","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[702,703]},"content":"主键索引","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[704,705]},"content":"非聚簇索引","children":[{"type":"list_item","depth":7,"payload":{"lines":[706,707]},"content":"全文索引","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[708,709]},"content":"唯一索引","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[710,711]},"content":"普通索引","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[712,713]},"content":"联合索引","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[714,715]},"content":"存储引擎","children":[{"type":"list_item","depth":5,"payload":{"lines":[716,717]},"content":"InnoDB","children":[{"type":"list_item","depth":6,"payload":{"lines":[718,719]},"content":"B+树","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[720,721]},"content":"支持事务、外键、行级锁","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[722,723]},"content":"MyISAM","children":[{"type":"list_item","depth":6,"payload":{"lines":[724,725]},"content":"不支持事务、行级锁、外键","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[726,727]},"content":"Memory","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[728,729]},"content":"sql优化","children":[{"type":"list_item","depth":5,"payload":{"lines":[730,731]},"content":"分析sql语句explain","children":[{"type":"list_item","depth":6,"payload":{"lines":[732,733]},"content":"id 在一个大的查询语句中每个SELECT关键字都对应一个 唯一的id","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[734,735]},"content":"select_type SELECT关键字对应的那个查询的类型","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[736,737]},"content":"table 表名","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[738,739]},"content":"partitions 匹配的分区信息","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[740,741]},"content":"type 针对单表的访问方法","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[742,743]},"content":"possible_keys 可能用到的索引","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[744,745]},"content":"key 实际上使用的索引","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[746,747]},"content":"key_len 实际使用到的索引长度","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[748,749]},"content":"ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[750,751]},"content":"rows 预估的需要读取的记录条数","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[752,753]},"content":"filtered 某个表经过搜索条件过滤后剩余记录条数的百分比","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[754,755]},"content":"Extra 一些额外的信息","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[756,757]},"content":"优化方式","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[758,759]},"content":"范式","children":[{"type":"list_item","depth":5,"payload":{"lines":[760,761]},"content":"第一范式（1NF）","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[762,763]},"content":"第二范式（2NF）","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[764,765]},"content":"第三范式（3NF）","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[766,767]},"content":"巴斯-科德范式（BCNF）","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[768,769]},"content":"第四范式(4NF）","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[770,771]},"content":"第五范式（5NF，又称完美","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[772,773]},"content":"数据库事务","children":[{"type":"list_item","depth":5,"payload":{"lines":[774,775]},"content":"ACID","children":[{"type":"list_item","depth":6,"payload":{"lines":[776,777]},"content":"原子性（atomicity）","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[778,779]},"content":"一致性（consistency）","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[780,781]},"content":"隔离性（isolation）","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[782,783]},"content":"持久性（durability）","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[784,785]},"content":"数据并发问题","children":[{"type":"list_item","depth":6,"payload":{"lines":[786,787]},"content":"脏写（ Dirty Write ）","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[788,789]},"content":"脏读（ Dirty Read ）","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[790,791]},"content":"不可重复读（ Non-Repeatable Read ）","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[792,793]},"content":"幻读（ Phantom ）","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[794,795]},"content":"隔离级别","children":[{"type":"list_item","depth":6,"payload":{"lines":[796,797]},"content":"READ UNCOMMITTED ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[798,799]},"content":"READ COMMITTED ：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[800,801]},"content":"REPEATABLE READ ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[802,803]},"content":"SERIALIZABLE ：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[804,805]},"content":"锁","children":[{"type":"list_item","depth":5,"payload":{"lines":[806,807]},"content":"按数据操作类型划分","children":[{"type":"list_item","depth":6,"payload":{"lines":[808,809]},"content":"读索/共享锁","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[810,811]},"content":"写锁/排他锁","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[812,813]},"content":"锁力度划分","children":[{"type":"list_item","depth":6,"payload":{"lines":[814,815]},"content":"表级锁","children":[{"type":"list_item","depth":7,"payload":{"lines":[816,817]},"content":"表级锁S锁、X锁","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[818,819]},"content":"意向锁","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[820,821]},"content":"自增锁","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[822,823]},"content":"MDL锁","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[824,825]},"content":"行级锁","children":[{"type":"list_item","depth":7,"payload":{"lines":[826,827]},"content":"Record Locks","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[828,829]},"content":"Gap Locks","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[830,831]},"content":"Next-Key LOcks","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[832,833]},"content":"插入意向锁","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[834,835]},"content":"页级锁","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[836,837]},"content":"对待锁的态度划分","children":[{"type":"list_item","depth":6,"payload":{"lines":[838,839]},"content":"悲观锁","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[840,841]},"content":"乐观锁","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[842,843]},"content":"加锁方式","children":[{"type":"list_item","depth":6,"payload":{"lines":[844,845]},"content":"隐式锁","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[846,847]},"content":"显示锁","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[848,849]},"content":"其他","children":[{"type":"list_item","depth":6,"payload":{"lines":[850,851]},"content":"全局锁","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[852,853]},"content":"死锁","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[854,855]},"content":"MVCC(多版本并发控制)","children":[{"type":"list_item","depth":5,"payload":{"lines":[856,857]},"content":"顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[858,859]},"content":"主从复制","children":[{"type":"list_item","depth":5,"payload":{"lines":[860,861]},"content":"提高数据库的吞吐量","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[862,863]},"content":"读写分离","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[864,865]},"content":"数据备份","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[866,867]},"content":"高可用性","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[868,869]},"content":"数据库备份","children":[{"type":"list_item","depth":5,"payload":{"lines":[870,871]},"content":"物理备份","children":[{"type":"list_item","depth":6,"payload":{"lines":[872,873]},"content":"备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用 xtrabackup 工具来进行物理备份","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[874,875]},"content":"逻辑备份","children":[{"type":"list_item","depth":6,"payload":{"lines":[876,877]},"content":"对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为 mysqldump 。逻辑备份就是 备份sql语句 ，在恢复的时候执行备份的sql语句实现数据库数据的重现。","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[878,879]},"content":"常见概念","children":[{"type":"list_item","depth":5,"payload":{"lines":[880,881]},"content":"覆盖索引","children":[{"type":"list_item","depth":6,"payload":{"lines":[882,883]},"content":"查找的字段刚好在索引上，不需要回表就可以获取到数据","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[884,885]},"content":"回表","children":[{"type":"list_item","depth":6,"payload":{"lines":[886,887]},"content":"查询的数据在索引上没有，需要根据id或者其他字段重新回表进行查找","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[888,889]},"content":"索引下推","children":[{"type":"list_item","depth":6,"payload":{"lines":[890,891]},"content":"概述","children":[{"type":"list_item","depth":7,"payload":{"lines":[892,893]},"content":"索引下推的下推其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[894,895]},"content":"目的","children":[{"type":"list_item","depth":7,"payload":{"lines":[896,897]},"content":"是为了减少回表次数，也就是要减少IO操作","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[898,899]},"content":"通俗来说","children":[{"type":"list_item","depth":7,"payload":{"lines":[900,901]},"content":"查找联合索引的时候，如果联合索引刚好都包含有查找条件的列，则先进行判断，不要回表","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[902,903]},"content":"https://baijiahao.baidu.com/s?id=1716515482593299829&amp;wfr=spider&amp;for=pc","children":[]}]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[904,905]},"content":"缓存数据库（NoSql）","children":[{"type":"list_item","depth":3,"payload":{"lines":[906,907]},"content":"redis","children":[{"type":"list_item","depth":4,"payload":{"lines":[908,909]},"content":"概述","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[910,911]},"content":"数据结构","children":[{"type":"list_item","depth":5,"payload":{"lines":[912,913]},"content":"String","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[914,915]},"content":"Hash","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[916,917]},"content":"List","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[918,919]},"content":"Set","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[920,921]},"content":"SortedSet","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[922,923]},"content":"发布订阅模式","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[924,925]},"content":"redis 哨兵机制","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[926,927]},"content":"redis 主从集群","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[928,929]},"content":"redis 分片集群","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[930,931]},"content":"常见问题","children":[{"type":"list_item","depth":5,"payload":{"lines":[932,933]},"content":"缓存雪崩","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[934,935]},"content":"缓存穿透","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[936,937]},"content":"缓存击穿","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[938,939]},"content":"数据一致性","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[940,941]},"content":"redis持久化","children":[{"type":"list_item","depth":5,"payload":{"lines":[942,943]},"content":"RDB","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[944,945]},"content":"AOF","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[946,947]},"content":"远程工具","children":[{"type":"list_item","depth":5,"payload":{"lines":[948,949]},"content":"Another Redis Desktop Manager","children":[]}]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[950,951]},"content":"mybatis","children":[{"type":"heading","depth":2,"payload":{"lines":[952,953]},"content":"概述","children":[{"type":"list_item","depth":3,"payload":{"lines":[954,955]},"content":"是一个开源、轻量级的数据持久化框架，简化了加载驱动、创建连接、创建 statement 等繁杂的过程，开发者只需要关注 SQL 语句本身","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[956,957]},"content":"执行流程","children":[{"type":"list_item","depth":3,"payload":{"lines":[958,959]},"content":"方法代理（MapperMethod)","children":[{"type":"list_item","depth":4,"payload":{"lines":[960,961]},"content":"与MyBatis交互的门面，存在的目的是为了方便调用，本身不会影响执行逻辑。","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[962,963]},"content":"会话（SqlSession）","children":[{"type":"list_item","depth":4,"payload":{"lines":[964,965]},"content":"与MyBatis交互的门面，所有对数据库操作必须经过它，但它不会真正去执行业务逻辑，而是交给Execute。另外他不是线程安全的所以不能跨线程调用。","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[966,967]},"content":"执行器（Execute）","children":[{"type":"list_item","depth":4,"payload":{"lines":[968,969]},"content":"真正执行业务逻辑的组件，其具体职能包括与JDBC交互，缓存管理、事物管理等。","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[970,971]},"content":"JDBC","children":[{"type":"list_item","depth":4,"payload":{"lines":[972,973]},"content":"处理sql","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[974,976]},"content":"","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[976,977]},"content":"Executor执行器","children":[{"type":"list_item","depth":3,"payload":{"lines":[978,979]},"content":"SimpleExecutor","children":[{"type":"list_item","depth":4,"payload":{"lines":[980,981]},"content":"（简单执行器），每次执行SQL需要预编译SQL语句。","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[982,983]},"content":"ReuseExecutor","children":[{"type":"list_item","depth":4,"payload":{"lines":[984,985]},"content":"（可重用执行器）同一SQL语句执行只需要预编译一次SQL语句","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[986,987]},"content":"BatchExecutor","children":[{"type":"list_item","depth":4,"payload":{"lines":[988,989]},"content":"（批处理执行器）只针对修改操作的SQL语句预编译一次，并且需要手动刷新SQL执行才生效。","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[990,991]},"content":"BaseExecutor","children":[{"type":"list_item","depth":4,"payload":{"lines":[992,993]},"content":"（执行器抽象类）执行上面3个执行器的重复操作，比如一级缓存、doQuery、doUpdate方法。","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[994,995]},"content":"缓存","children":[{"type":"list_item","depth":3,"payload":{"lines":[996,997]},"content":"一级缓存（默认开启）","children":[{"type":"list_item","depth":4,"payload":{"lines":[998,999]},"content":"也叫做会话级缓存，生命周期仅存在于当前会话，不可以直接关关闭。但可以通过flushCache和localCacheScope对其做相应控制。","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1000,1001]},"content":"缓存命中参数","children":[{"type":"list_item","depth":5,"payload":{"lines":[1002,1003]},"content":"SQL与参数相同","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1004,1005]},"content":"同一个会话","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1006,1007]},"content":"RowBounds行范围相同","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1008,1009]},"content":"相同的MapperStatement ID","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[1010,1011]},"content":"清空缓存","children":[{"type":"list_item","depth":5,"payload":{"lines":[1012,1013]},"content":"update: 执行任意增删改","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1014,1015]},"content":"缓存的清空对应BaseExecutor中的 clearLocalCache.方法，clearLocalCache 不是清空某条具体数据，而清当前会话下所有一级缓存数据。","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1016,1017]},"content":"select：查询又分为两种情况清空，一前置清空，即配置了flushCache=true。2后置清空，配置了缓存作用域为statement 查询结束合会清空缓存。","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1018,1019]},"content":"commit：提交前清空","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1020,1021]},"content":"Rolback：回滚前清空","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[1022,1023]},"content":"二级缓存（需要手动开启）","children":[{"type":"list_item","depth":4,"payload":{"lines":[1024,1025]},"content":"也叫应用级性缓存，缓存对象存在于整个应用周期，而且可以跨线程使用","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1026,1027]},"content":"CachingExecutor","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1028,1029]},"content":"关联映射","children":[{"type":"list_item","depth":3,"payload":{"lines":[1030,1031]},"content":"映射工具MetaObject","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1032,1033]},"content":"ResultMap结果集映射","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1034,1035]},"content":"懒加载","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1036,1037]},"content":"嵌套映射","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1038,1039]},"content":"动态sql：if/where/foreach/choose（when, otherwise）/set/bind/trim","children":[{"type":"list_item","depth":3,"payload":{"lines":[1040,1041]},"content":"动态SQL脚本","children":[{"type":"list_item","depth":4,"payload":{"lines":[1042,1043]},"content":"SqlNode","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1044,1045]},"content":"OGNL表达式","children":[{"type":"list_item","depth":3,"payload":{"lines":[1046,1047]},"content":"id!=null||autho.name!=null","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1048,1049]},"content":"mybatis配置（SqlsessionFactory）","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1050,1051]},"content":"Mapper XML文件的使用：insert/update/delete/select/ResultMap","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1052,1053]},"content":"插件开发","children":[{"type":"list_item","depth":3,"payload":{"lines":[1054,1055]},"content":"分页插件","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1056,1057]},"content":"数据权限插件","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1058,1059]},"content":"ResultSetHandler（结果集映射）","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1060,1061]},"content":"StatementHandler","children":[{"type":"list_item","depth":3,"payload":{"lines":[1062,1063]},"content":"BaseStatementHandler","children":[{"type":"list_item","depth":4,"payload":{"lines":[1064,1065]},"content":"SimpleStatementHandler","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1066,1067]},"content":"PreparedStatementHandler","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1068,1069]},"content":"CallableStatementHandler","children":[]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1070,1071]},"content":"spring","children":[{"type":"heading","depth":2,"payload":{"lines":[1072,1073]},"content":"概述","children":[{"type":"list_item","depth":3,"payload":{"lines":[1074,1075]},"content":"是目前主流的轻量级别的 Java Web 开发框架，以IOC、AOP为核心","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1076,1077]},"content":"依赖注入（DI、IOC）","children":[{"type":"list_item","depth":3,"payload":{"lines":[1078,1079]},"content":"DI","children":[{"type":"list_item","depth":4,"payload":{"lines":[1080,1081]},"content":"即依赖注入，对象之间的依赖由容器在运行期决定，即容器动态的将某个依赖注入到对象之中","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1082,1083]},"content":"基于XML配置注入依赖","children":[{"type":"list_item","depth":5,"payload":{"lines":[1084,1086]},"content":"","children":[{"type":"list_item","depth":6,"payload":{"lines":[1084,1085],"index":1},"content":"1. 有参构造函数注入依赖","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1086,1088]},"content":"","children":[{"type":"list_item","depth":6,"payload":{"lines":[1086,1087],"index":2},"content":"2. set方法注入依赖","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1088,1090]},"content":"","children":[{"type":"list_item","depth":6,"payload":{"lines":[1088,1089],"index":3},"content":"3. 注入自定义类型","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1090,1092]},"content":"","children":[{"type":"list_item","depth":6,"payload":{"lines":[1090,1091],"index":4},"content":"4. 注入集合类型","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[1092,1093]},"content":"基于注解形式注入依赖","children":[{"type":"list_item","depth":5,"payload":{"lines":[1094,1096]},"content":"","children":[{"type":"list_item","depth":6,"payload":{"lines":[1094,1095],"index":1},"content":"1. @Autowired","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1096,1098]},"content":"","children":[{"type":"list_item","depth":6,"payload":{"lines":[1096,1097],"index":2},"content":"2. @Resource","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1098,1100]},"content":"","children":[{"type":"list_item","depth":6,"payload":{"lines":[1098,1099],"index":3},"content":"3. @Value","children":[]}]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[1100,1101]},"content":"IOC","children":[{"type":"list_item","depth":4,"payload":{"lines":[1102,1103]},"content":"控制反转，将对象的创建进行反转，常规情况下，对象都是开发者手动创建的，使用IOC开发者不再需要创建对象，而是由IOC容器根据需求自动创建项目所需要的对象。","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1104,1105]},"content":"AOP切面编程","children":[{"type":"list_item","depth":3,"payload":{"lines":[1106,1107]},"content":"Spring AOP","children":[{"type":"list_item","depth":4,"payload":{"lines":[1108,1109]},"content":"使用场景","children":[{"type":"list_item","depth":5,"payload":{"lines":[1110,1111]},"content":"数据权限过滤","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1112,1113]},"content":"防重复提交","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1114,1115]},"content":"数据字典翻译","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1116,1117]},"content":"日志记录","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[1118,1119]},"content":"概念","children":[{"type":"list_item","depth":5,"payload":{"lines":[1120,1121]},"content":"aspect","children":[{"type":"list_item","depth":6,"payload":{"lines":[1122,1123]},"content":"切面，切面有切点和通知组成，即包括横切逻辑的定义也包括连接点的定义","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1124,1125]},"content":"pointcut","children":[{"type":"list_item","depth":6,"payload":{"lines":[1126,1127]},"content":"切点，每个类都拥有多个连接点，可以理解是连接点的集合","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1128,1129]},"content":"joinpoint","children":[{"type":"list_item","depth":6,"payload":{"lines":[1130,1131]},"content":"连接点，程序执行的某个特定位置，如某个方法调用前后等","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1132,1133]},"content":"weaving","children":[{"type":"list_item","depth":6,"payload":{"lines":[1134,1135]},"content":"织入，将增强添加到目标类的具体连接点的过程","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1136,1137]},"content":"advice","children":[{"type":"list_item","depth":6,"payload":{"lines":[1138,1139]},"content":"通知，是织入到目标类连接点上的一段代码，就是增强到什么地方?增强什么内容?","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1140,1141]},"content":"Before advice","children":[{"type":"list_item","depth":7,"payload":{"lines":[1142,1143]},"content":"前置通知，即在目标方法调用之前执行。注意:即无论方法是否遇到异常都执行","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[1144,1145]},"content":"After returning advice","children":[{"type":"list_item","depth":7,"payload":{"lines":[1146,1147]},"content":"后置通知，在目标方法执行后执行，前提是目标方法没有遇到异常，如果有异常则不执行通知","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[1148,1149]},"content":"After throwing advice","children":[{"type":"list_item","depth":7,"payload":{"lines":[1150,1151]},"content":"异常通知，在目标方法抛出异常时执行，可以获取异常信息","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[1152,1153]},"content":"After finally advice","children":[{"type":"list_item","depth":7,"payload":{"lines":[1154,1155]},"content":"最终通知，在目标方法执行后执行，无论是否是异常执行","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[1156,1157]},"content":"Around advice","children":[{"type":"list_item","depth":7,"payload":{"lines":[1158,1159]},"content":"环绕通知，最强大的通知类型，可以控制目标方法的执行(通过调用ProceedingJoinPoint.proceed())可以在目标执行全过程中进行执行","children":[]}]}]},{"type":"list_item","depth":5,"payload":{"lines":[1160,1161]},"content":"target","children":[{"type":"list_item","depth":6,"payload":{"lines":[1162,1163]},"content":"目标对象，通知织入的目标类","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1164,1165]},"content":"aop Proxy","children":[{"type":"list_item","depth":6,"payload":{"lines":[1166,1167]},"content":"代理对象，即增强后产生的对象","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[1168,1169]},"content":"动态代理","children":[{"type":"list_item","depth":5,"payload":{"lines":[1170,1171]},"content":"JDK动态代理","children":[{"type":"list_item","depth":6,"payload":{"lines":[1172,1173]},"content":"基于接口提供动态代理功能","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1174,1175]},"content":"InvocationHandler","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1176,1177]},"content":"Cglib动态代理","children":[{"type":"list_item","depth":6,"payload":{"lines":[1178,1179]},"content":"基于类继承创建代理类","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1180,1181]},"content":"MethodInterceptor","children":[]}]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[1182,1183]},"content":"AspectJ","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1184,1185]},"content":"常用注解","children":[{"type":"list_item","depth":3,"payload":{"lines":[1186,1187]},"content":"声明bean的注解","children":[{"type":"list_item","depth":4,"payload":{"lines":[1188,1189]},"content":"@Controller 控制层","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1190,1191]},"content":"@Service 业务层","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1192,1193]},"content":"@Repository 数据访问层","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1194,1195]},"content":"@Component 是所有受Spring 管理组件的通用形式","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1196,1197]},"content":"@Bean：注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1198,1199]},"content":"注入bean的注解","children":[{"type":"list_item","depth":4,"payload":{"lines":[1200,1201]},"content":"@Autowired：由Spring提供，byType方式","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1202,1203]},"content":"@Resource：由JSR-250提供，默认byType方式","children":[{"type":"list_item","depth":5,"payload":{"lines":[1204,1205]},"content":"@Qualifier，byName方式","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[1206,1207]},"content":"Java配置类相关注解","children":[{"type":"list_item","depth":4,"payload":{"lines":[1208,1209]},"content":"@Configuration：声明当前类为配置类","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1210,1211]},"content":"@Bean：注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1212,1213]},"content":"@ComponentScan：用于对Component进行扫描","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1214,1215]},"content":"@Scope  设置类型包括：设置Spring容器如何新建Bean实例","children":[{"type":"list_item","depth":4,"payload":{"lines":[1216,1217]},"content":"Singleton：单例,一个Spring容器中只有一个bean实例，默认模式","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1218,1219]},"content":"Protetype：每次调用新建一个bean","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1220,1221]},"content":"Request：web项目中，给每个http request新建一个bean","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1222,1223]},"content":"Session：web项目中，给每个http session新建一个bean","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1224,1225]},"content":"GlobalSession：给每一个 global http session新建一个Bean实例","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1226,1227]},"content":"切面（AOP）相关注解","children":[{"type":"list_item","depth":4,"payload":{"lines":[1228,1229]},"content":"@Aspect：声明一个切面","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1230,1231]},"content":"@After：在方法执行之后执行（方法上）","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1232,1233]},"content":"@Before：在方法执行之前执行（方法上）","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1234,1235]},"content":"@Around：在方法执行之前与之后执行（方法上）","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1236,1237]},"content":"@PointCut：声明切点","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1238,1239]},"content":"@EnableAspectJAutoProxy：开启Spring对AspectJ代理的支持","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1240,1241]},"content":"取值注解","children":[{"type":"list_item","depth":4,"payload":{"lines":[1242,1243]},"content":"@Value注解","children":[{"type":"list_item","depth":5,"payload":{"lines":[1244,1245]},"content":"将固定值或SpEL表示式获取到的值绑定到方法参数","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[1246,1247]},"content":"环境切换","children":[{"type":"list_item","depth":4,"payload":{"lines":[1248,1249]},"content":"@Profile","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1250,1251]},"content":"@Conditional","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1252,1253]},"content":"异步相关","children":[{"type":"list_item","depth":4,"payload":{"lines":[1254,1255]},"content":"@EnableAsync","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1256,1257]},"content":"@Async","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1258,1259]},"content":"Bean的生命周期","children":[{"type":"list_item","depth":3,"payload":{"lines":[1260,1262]},"content":"","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1262,1263]},"content":"1）根据配置情况调用 Bean 构造方法或工厂方法实例化 Bean","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1264,1265]},"content":"2）通过populateBean()方法利用依赖注入完成 Bean 中所有属性值的配置注入。","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1266,1267]},"content":"3）如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1268,1269]},"content":"4）如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1270,1271]},"content":"5）如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1272,1273]},"content":"6）如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1274,1275]},"content":"7）如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1276,1277]},"content":"8）如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1278,1279]},"content":"9）如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1280,1281]},"content":"10）如果在 <bean> 中指定了该 Bean 的作用范围为 scope=&quot;singleton&quot;，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在 <bean> 中指定了该 Bean 的作用范围为 scope=&quot;prototype&quot;，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1282,1283]},"content":"11）如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1284,1285]},"content":"循环依赖","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1286,1287]},"content":"事务","children":[{"type":"list_item","depth":3,"payload":{"lines":[1288,1289]},"content":"编程式事务","children":[{"type":"list_item","depth":4,"payload":{"lines":[1290,1291]},"content":"将事务管理代码嵌入嵌入到业务代码中，来控制事务的提交和回滚","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1292,1293]},"content":"声明式事务","children":[{"type":"list_item","depth":4,"payload":{"lines":[1294,1295]},"content":"@Transactional","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1296,1297]},"content":"事务的传播","children":[{"type":"list_item","depth":4,"payload":{"lines":[1298,1299]},"content":"PROPAGATION_REQUIRED","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1300,1301]},"content":"PROPAGATION_REQUIRES_NEW","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1302,1303]},"content":"PROPAGATION_NESTED","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1304,1305]},"content":"PROPAGATION_SUPPORTS","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1306,1307]},"content":"PROPAGATION_NOT_SUPPORTED","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1308,1309]},"content":"PROPAGATION_MANDATORY","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1310,1311]},"content":"PROPAGATION_NEVER","children":[]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1312,1313]},"content":"SpringMVC","children":[{"type":"heading","depth":2,"payload":{"lines":[1314,1315]},"content":"五大组件","children":[{"type":"list_item","depth":3,"payload":{"lines":[1316,1317]},"content":"DispatcherServlet（前端控制器）","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1318,1319]},"content":"HandlerMapping（处理映射器）","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1320,1321]},"content":"HandlerAdaptor（处理适配器）","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1322,1323]},"content":"Controller(Servlet)（控制器）","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1324,1325]},"content":"ViewResoler（视图解析器）","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1326,1327]},"content":"模型Model","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1328,1329]},"content":"视图View","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1330,1331]},"content":"拦截器","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1332,1333]},"content":"校验框架validation","children":[{"type":"list_item","depth":3,"payload":{"lines":[1334,1335]},"content":"@Null","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1336,1337]},"content":"@NotNull","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1338,1339]},"content":"@NotEmpty","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1340,1341]},"content":"@NotBlank","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1342,1343]},"content":"@Size","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1344,1345]},"content":"@Max","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1346,1347]},"content":"@Min","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1348,1349]},"content":"Spring MVC异常处理","children":[{"type":"list_item","depth":3,"payload":{"lines":[1350,1351]},"content":"定义一个全局异常处理类，返回统一规范的异常信息","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1352,1353]},"content":"Spring MVC处理流程","children":[{"type":"list_item","depth":3,"payload":{"lines":[1356,1357]},"content":"1 DispatcherSerlet接收客户端的请求","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1358,1359]},"content":"2 DispatcherServlet调用HandlerMapping根据请求的路径查找对应的Controller","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1360,1361]},"content":"3 DispatcherServlet调用HandlerAdaptor完成指定Controller方法的调用","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1362,1363]},"content":"4 Controller运行方法，返回流、跳转地址或模型视图对象ModelAndView","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1364,1365]},"content":"5 DispatcherServlet调用ViewResolor以逻辑视图名获取视图","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1366,1367]},"content":"6 DispatcherServlet渲染视图，之後将视图转化响应并返回","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1368,1369]},"content":"Servlet","children":[{"type":"list_item","depth":3,"payload":{"lines":[1370,1371]},"content":"概述","children":[{"type":"list_item","depth":4,"payload":{"lines":[1372,1373]},"content":"运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1374,1375]},"content":"生命周期","children":[{"type":"list_item","depth":4,"payload":{"lines":[1376,1377]},"content":"Servlet 初始化后调用 init () 方法","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1378,1379]},"content":"Servlet 调用 service() 方法来处理客户端的请求","children":[{"type":"list_item","depth":5,"payload":{"lines":[1380,1381]},"content":"doGet()","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1382,1383]},"content":"doPost()","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[1384,1385]},"content":"Servlet 销毁前调用 destroy() 方法","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1386,1387]},"content":"最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1388,1389]},"content":"常用注解","children":[{"type":"list_item","depth":3,"payload":{"lines":[1390,1391]},"content":"@RequestMapping：用于映射web请求，包括访问路径和参数","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1392,1393]},"content":"@ResponseBody：支持将返回值放到response内，而不是一个页面，通常用户返回json数据","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1394,1395]},"content":"@RequestBody：允许request的参数在request体中，而不是在直接连接的地址后面","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1396,1397]},"content":"@PathVariable：用于接收路径参数，比如@RequestMapping(“/hello/{name}”)声明的路径","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1398,1399]},"content":"@RestController：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1400,1401]},"content":"@ControllerAdvice：全局异常处理、全局数据绑定、全局数据预处理","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1402,1403]},"content":"@ExceptionHandler：用于全局处理控制器里的异常","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1404,1405]},"content":"@InitBinder：用来设置WebDataBinder","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1406,1407]},"content":"springboot","children":[{"type":"heading","depth":2,"payload":{"lines":[1408,1409]},"content":"概述","children":[{"type":"list_item","depth":3,"payload":{"lines":[1410,1411]},"content":"spring boot只是一个用于加速开发spring应用的基础框架，简化工作","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1412,1413]},"content":"内嵌tomcat和jetty容器，不需要单独安装容器，jar包直接发布一个web应用，以普通的java程序形式运行。","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1414,1415]},"content":"自动装配原理","children":[{"type":"list_item","depth":3,"payload":{"lines":[1416,1417]},"content":"@SpringBootApplication","children":[{"type":"list_item","depth":4,"payload":{"lines":[1418,1419]},"content":"@SpringBootConfiguration","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1420,1421]},"content":"@EnableAutoConfiguration  开启自动配置","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1422,1423]},"content":"@ComponentScan  组件扫描","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1424,1425]},"content":"@Conditional （按条件自动装配）","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1426,1427]},"content":"Spring Boot Starter","children":[{"type":"list_item","depth":3,"payload":{"lines":[1428,1429]},"content":"Spring Boot启动程序都遵循相同的命名模式 spring-boot-starter-* ，其中 * 表示它是应用程序的一种类型","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1430,1431]},"content":"如何自定义starter","children":[{"type":"list_item","depth":4,"payload":{"lines":[1432,1433]},"content":"新建Maven项目，在项目的POM文件中定义使用的依赖；","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1434,1435]},"content":"新建配置类，写好配置项和默认的配置值，指明配置项前缀；","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1436,1437]},"content":"新建自动装配类，使用@Configuration和@Bean来进行自动装配；","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1438,1439]},"content":"新建spring.factories文件，指定Starter的自动装配类；","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1440,1441]},"content":"SpringApplication生命周期","children":[{"type":"list_item","depth":3,"payload":{"lines":[1442,1443]},"content":"初始化阶段","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1444,1445]},"content":"运行阶段","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1446,1447]},"content":"结束阶段","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1448,1449]},"content":"应用退出","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1450,1451]},"content":"Spring Boot运行器(Runner)","children":[{"type":"list_item","depth":3,"payload":{"lines":[1452,1453]},"content":"概述","children":[{"type":"list_item","depth":4,"payload":{"lines":[1454,1455]},"content":"一般项目在部署启动后，需要执行一些诸如清除缓存等初始化的工作，虽然可以通过人工手动调用接口等方式完成，但是会容易遗漏，且不够优雅。这里推荐使用SpringBoot的Runner启动器，其会在服务启动后自动地执行相关初始化任务","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1456,1457]},"content":"CommandLineRunner（命令行Runner接口）","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1458,1459]},"content":"ApplicationRunner（应用程序运行器Runner）","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1460,1461]},"content":"ApplicationListener","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1462,1463]},"content":"常用注解","children":[{"type":"list_item","depth":3,"payload":{"lines":[1464,1465]},"content":"@SpringBootApplication","children":[{"type":"list_item","depth":4,"payload":{"lines":[1466,1467]},"content":"@SpringBootConfiguration","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1468,1469]},"content":"@EnableAutoConfiguration","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1470,1471]},"content":"@ComponentScan","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1472,1473]},"content":"@Import 导入额外的配置信息","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1474,1475]},"content":"springcloud","children":[{"type":"heading","depth":2,"payload":{"lines":[1476,1477]},"content":"概述","children":[{"type":"list_item","depth":3,"payload":{"lines":[1478,1479]},"content":"Spring Cloud是一个微服务框架的规范，注意，只是规范，他不是任何具体的框架","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1480,1481]},"content":"五大组件","children":[{"type":"list_item","depth":3,"payload":{"lines":[1482,1483]},"content":"服务注册与发现","children":[{"type":"list_item","depth":4,"payload":{"lines":[1484,1485]},"content":"Eureka","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1486,1487]},"content":"配置中心","children":[{"type":"list_item","depth":4,"payload":{"lines":[1488,1489]},"content":"SpringClud Config","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1490,1491]},"content":"API网关","children":[{"type":"list_item","depth":4,"payload":{"lines":[1492,1493]},"content":"Zuul","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1494,1495]},"content":"Gateway(Spring Cloud原生)","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1496,1497]},"content":"负载均衡","children":[{"type":"list_item","depth":4,"payload":{"lines":[1498,1499]},"content":"Ribbon (Netflix套件)","children":[{"type":"list_item","depth":5,"payload":{"lines":[1500,1501]},"content":"负载均衡算法","children":[{"type":"list_item","depth":6,"payload":{"lines":[1502,1503]},"content":"RoundRobinRule   轮训策略","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1504,1505]},"content":"RandomRule    随机策略","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1506,1507]},"content":"weightedResponseTimeRule  响应时间加权策略","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1508,1509]},"content":"RetryRule   重试策略","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1510,1511]},"content":"AvailabilityFilteringRule  可用过滤策略","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[1512,1513]},"content":"Feign （Netflix套件）","children":[{"type":"list_item","depth":5,"payload":{"lines":[1514,1515]},"content":"它是一个伪http，实质是对RestTemplate进行再封装，解决RestTemplate的问题","children":[]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[1516,1517]},"content":"服务限流熔断","children":[{"type":"list_item","depth":4,"payload":{"lines":[1518,1519]},"content":"Hystrix（Netflix套件）","children":[{"type":"list_item","depth":5,"payload":{"lines":[1520,1521]},"content":"服务雪崩","children":[{"type":"list_item","depth":6,"payload":{"lines":[1522,1523]},"content":"在微服务之间进行服务调用是由于某一个服务故障， 导致级联服务故障的现象，称为雪崩效应","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1524,1525]},"content":"服务熔断","children":[{"type":"list_item","depth":6,"payload":{"lines":[1526,1527]},"content":"“熔断器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器(hystrix)的故障监控， 某个异常条件被触发，直接熔断整个服务","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1528,1529]},"content":"服务降级","children":[{"type":"list_item","depth":6,"payload":{"lines":[1530,1531]},"content":"服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此缓解服务器的压力，以保证核心任务的进行","children":[]}]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1532,1533]},"content":"消息总线","children":[{"type":"list_item","depth":3,"payload":{"lines":[1534,1535]},"content":"bus","children":[{"type":"list_item","depth":4,"payload":{"lines":[1536,1537]},"content":"概述：bus称之为springcloud中消息总线,主要用来在微服务系统中实现远端配置更新时通过广播形式通知所有客户端刷新配置信息，避免手动重启服务的工作","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1538,1539]},"content":"链路监控","children":[{"type":"list_item","depth":3,"payload":{"lines":[1540,1541]},"content":"Spring Cloud sleuth(Spring cloud原生)","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1542,1543]},"content":"zipkin(Twitter)","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1544,1545]},"content":"服务监控","children":[{"type":"list_item","depth":3,"payload":{"lines":[1546,1547]},"content":"Spring Boot Admin","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1548,1549]},"content":"常用注解","children":[{"type":"list_item","depth":3,"payload":{"lines":[1550,1551]},"content":"@EnableEurekaServer","children":[{"type":"list_item","depth":4,"payload":{"lines":[1552,1553]},"content":"用在springboot启动类上，表示这是一个eureka服务注册中心","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1554,1555]},"content":"@EnableDiscoveryClient","children":[{"type":"list_item","depth":4,"payload":{"lines":[1556,1557]},"content":"用在springboot启动类上表示这是一个服务，可以被注册中心找到","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1558,1559]},"content":"@LoadBalanced","children":[{"type":"list_item","depth":4,"payload":{"lines":[1560,1561]},"content":"开启负载均衡能力","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1562,1563]},"content":"@EnableCircuitBreaker","children":[{"type":"list_item","depth":4,"payload":{"lines":[1564,1565]},"content":"用在启动类上，开启断路器功能","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1566,1567]},"content":"@HystrixCommand(fallbackMethod=”backMethod”)","children":[{"type":"list_item","depth":4,"payload":{"lines":[1568,1569]},"content":"用在方法上，fallbackMethod指定断路回调方法","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1570,1571]},"content":"@EnableConfigServer","children":[{"type":"list_item","depth":4,"payload":{"lines":[1572,1573]},"content":"用在启动类上，表示这是一个配置中心，开启Config Server","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1574,1575]},"content":"@EnableZuulProxy","children":[{"type":"list_item","depth":4,"payload":{"lines":[1576,1577]},"content":"开启zuul路由，用在启动类上；","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1578,1579]},"content":"@SpringCloudApplication","children":[{"type":"list_item","depth":4,"payload":{"lines":[1580,1581]},"content":"@SpringBootApplication","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1582,1583]},"content":"@EnableDiscovertyClient","children":[]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1584,1585]},"content":"springcloud alibaba","children":[{"type":"heading","depth":2,"payload":{"lines":[1586,1587]},"content":"服务注册与发现","children":[{"type":"list_item","depth":3,"payload":{"lines":[1588,1589]},"content":"Nacos","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1590,1591]},"content":"API网关","children":[{"type":"list_item","depth":3,"payload":{"lines":[1592,1593]},"content":"Nacos","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1594,1595]},"content":"负载均衡","children":[{"type":"list_item","depth":3,"payload":{"lines":[1596,1597]},"content":"Ribbon (Netflix套件)","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1598,1599]},"content":"Feign （Netflix套件）","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1600,1601]},"content":"服务限流熔断","children":[{"type":"list_item","depth":3,"payload":{"lines":[1602,1603]},"content":"Sentinel(Alibaba)","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1604,1605]},"content":"链路监控","children":[{"type":"list_item","depth":3,"payload":{"lines":[1606,1607]},"content":"SkyWalking","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1608,1609]},"content":"服务监控","children":[{"type":"list_item","depth":3,"payload":{"lines":[1610,1611]},"content":"Spring Boot Admin","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1612,1613]},"content":"分布式事务","children":[{"type":"list_item","depth":3,"payload":{"lines":[1614,1615]},"content":"Seata","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1616,1617]},"content":"其他技术","children":[{"type":"heading","depth":2,"payload":{"lines":[1618,1619]},"content":"工作流","children":[{"type":"list_item","depth":3,"payload":{"lines":[1620,1621]},"content":"Flowable","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1622,1623]},"content":"Activiti","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1624,1625]},"content":"消息队列","children":[{"type":"list_item","depth":3,"payload":{"lines":[1626,1627]},"content":"RabbitMQ","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1628,1629]},"content":"RocketMQ","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1630,1631]},"content":"Kafka","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1632,1633]},"content":"ActiveMQ","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1634,1635]},"content":"权限控制","children":[{"type":"list_item","depth":3,"payload":{"lines":[1636,1637]},"content":"JWT","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1638,1639]},"content":"Shiro、Spring Security","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1640,1641]},"content":"单点登录","children":[{"type":"list_item","depth":4,"payload":{"lines":[1642,1643]},"content":"CAS","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1644,1645]},"content":"OAuth","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1646,1647]},"content":"定时任务","children":[{"type":"list_item","depth":3,"payload":{"lines":[1648,1649]},"content":"quartz","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1650,1651]},"content":"xxl-job","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1652,1653]},"content":"Spring Scheduler","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1654,1655]},"content":"对象存储OSS","children":[{"type":"list_item","depth":3,"payload":{"lines":[1656,1657]},"content":"MINIO","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1658,1659]},"content":"FastDFS","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1660,1661]},"content":"全文检索","children":[{"type":"list_item","depth":3,"payload":{"lines":[1662,1663]},"content":"Elastic Search","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1664,1665]},"content":"分库分表","children":[{"type":"list_item","depth":3,"payload":{"lines":[1666,1667]},"content":"shardingsphere","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1668,1669]},"content":"mycat","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1670,1671]},"content":"部署、运维","children":[{"type":"list_item","depth":3,"payload":{"lines":[1672,1673]},"content":"Docker","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1674,1675]},"content":"k8s","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1676,1677]},"content":"Rancher","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1678,1679]},"content":"Jenkins","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1680,1681]},"content":"文件预览","children":[{"type":"list_item","depth":3,"payload":{"lines":[1682,1683]},"content":"kkFileView","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1684,1685]},"content":"设计原则与设计规范","children":[{"type":"heading","depth":2,"payload":{"lines":[1686,1687]},"content":"设计原则","children":[{"type":"list_item","depth":3,"payload":{"lines":[1688,1689]},"content":"单一职责原则","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1690,1691]},"content":"开闭原则","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1692,1693]},"content":"接口隔离原则","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1694,1695]},"content":"里式替换","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1696,1697]},"content":"控制反转、依赖反转、依赖注入","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1698,1699]},"content":"KISS、YAGNI原则","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1700,1701]},"content":"迪米特法则（LOD）","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1702,1703]},"content":"重构技巧","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1704,1705]},"content":"编程规范","children":[{"type":"list_item","depth":3,"payload":{"lines":[1706,1707]},"content":"代码规范","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1708,1709]},"content":"数据库设计规范","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1710,1711]},"content":"设计规范","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1712,1713]},"content":"部署规范","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1714,1715]},"content":"面向对象","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[1716,1717]},"content":"23种设计模式","children":[{"type":"heading","depth":2,"payload":{"lines":[1718,1719]},"content":"创建型5","children":[{"type":"list_item","depth":3,"payload":{"lines":[1720,1721]},"content":"单例模式","children":[{"type":"list_item","depth":4,"payload":{"lines":[1722,1723]},"content":"懒汉模式","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1724,1725]},"content":"饿汉模式","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1726,1727]},"content":"抽象工厂","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1728,1729]},"content":"工厂模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1730,1731]},"content":"建造者模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1732,1733]},"content":"原型模式","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1734,1735]},"content":"结构性7","children":[{"type":"list_item","depth":3,"payload":{"lines":[1736,1737]},"content":"代理模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1738,1739]},"content":"桥接模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1740,1741]},"content":"装饰器模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1742,1743]},"content":"适配器模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1744,1745]},"content":"门面模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1746,1747]},"content":"组合模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1748,1749]},"content":"享元模式","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1750,1751]},"content":"行为型11","children":[{"type":"list_item","depth":3,"payload":{"lines":[1752,1753]},"content":"观察者模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1754,1755]},"content":"模板模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1756,1757]},"content":"策略模式","children":[{"type":"list_item","depth":4,"payload":{"lines":[1758,1759]},"content":"解决if/else","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1760,1761]},"content":"责任链模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1762,1763]},"content":"状态模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1764,1765]},"content":"迭代器模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1766,1767]},"content":"访问者模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1768,1769]},"content":"备忘录模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1770,1771]},"content":"解释器模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1772,1773]},"content":"中介模式","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1774,1775]},"content":"命令模式","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1776,1777]},"content":"基础软件技术","children":[{"type":"heading","depth":2,"payload":{"lines":[1778,1779]},"content":"Nginx","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1780,1781]},"content":"json数据格式","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1782,1783]},"content":"XML","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1784,1785]},"content":"maven","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1786,1787]},"content":"git","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1788,1789]},"content":"markdown","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1790,1791]},"content":"RPC","children":[{"type":"list_item","depth":3,"payload":{"lines":[1792,1793]},"content":"Web Service","children":[{"type":"list_item","depth":4,"payload":{"lines":[1794,1795]},"content":"WSDL","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1796,1797]},"content":"SOAP面向服务编程","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1798,1799]},"content":"Dubbo","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1800,1801]},"content":"WebSocket","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1802,1803]},"content":"物联网协议","children":[{"type":"list_item","depth":3,"payload":{"lines":[1804,1805]},"content":"MQTT","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1806,1807]},"content":"计算机基础知识","children":[{"type":"heading","depth":2,"payload":{"lines":[1808,1809]},"content":"计算机组成原理","children":[{"type":"list_item","depth":3,"payload":{"lines":[1810,1811]},"content":"死锁","children":[{"type":"list_item","depth":4,"payload":{"lines":[1812,1813]},"content":"概念","children":[{"type":"list_item","depth":5,"payload":{"lines":[1814,1815]},"content":"系统中两个或两个以上的进程无限期地相互等待永远不会发生的条件，系统处于一种停滞状态，这种情况称为死锁","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[1816,1817]},"content":"产生死锁的四个要条件","children":[{"type":"list_item","depth":5,"payload":{"lines":[1818,1819]},"content":"互斥条件：任一时刻只允许一个进程使用资源","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1820,1821]},"content":"非剥夺条件：进程已经占用的资源，不会被强制剥夺","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1822,1823]},"content":"占用并请求条件：进程占有部分资源，申请更多的资源，且不会释放已经占有的资源","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1824,1825]},"content":"循环等待：请求资源的进程形成了循环","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[1826,1827]},"content":"处理策略","children":[{"type":"list_item","depth":5,"payload":{"lines":[1828,1829]},"content":"忽略死锁","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1830,1831]},"content":"死锁的检测与恢复","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1832,1833]},"content":"死锁的避免","children":[{"type":"list_item","depth":6,"payload":{"lines":[1834,1835]},"content":"银行家算法","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1836,1837]},"content":"死锁的预防","children":[]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1838,1839]},"content":"操作系统","children":[{"type":"list_item","depth":3,"payload":{"lines":[1840,1841]},"content":"Linux","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1842,1843]},"content":"计算机网络","children":[{"type":"list_item","depth":3,"payload":{"lines":[1844,1845]},"content":"TCP/IP","children":[{"type":"list_item","depth":4,"payload":{"lines":[1846,1847]},"content":"IP","children":[{"type":"list_item","depth":5,"payload":{"lines":[1848,1849]},"content":"IP地址是由32位二进制数，即4个字节组成的，由网络号和主机号两个字段组成。","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1850,1851]},"content":"IPv6协议","children":[{"type":"list_item","depth":6,"payload":{"lines":[1852,1853]},"content":"IPv6协议，全称“互联网协议第6版","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1854,1855]},"content":"IPv6地址长度为128位","children":[]}]}]}]},{"type":"list_item","depth":3,"payload":{"lines":[1856,1857]},"content":"路由器","children":[{"type":"list_item","depth":4,"payload":{"lines":[1858,1859]},"content":"路由器是网络层的互联设备，用于连接多个逻辑上分开的网络，所谓逻辑网络就是拥有独立网络地址的网络","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1860,1861]},"content":"交换机","children":[{"type":"list_item","depth":4,"payload":{"lines":[1862,1863]},"content":"也称多端口网桥，工作在数据链路层，能够识别帧的内容。交换机在同一时刻可进行多个端口对之间的数据传输","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1864,1865]},"content":"VPN","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1866,1867]},"content":"防火墙","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1868,1869]},"content":"NAT","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1870,1871]},"content":"网络通信协议","children":[{"type":"list_item","depth":4,"payload":{"lines":[1872,1873]},"content":"应用层","children":[{"type":"list_item","depth":5,"payload":{"lines":[1874,1875]},"content":"FTP、Telnet、DNS","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[1876,1877]},"content":"HTTP(超文本传输协议)","children":[{"type":"list_item","depth":6,"payload":{"lines":[1878,1879]},"content":"常见状态码","children":[{"type":"list_item","depth":7,"payload":{"lines":[1880,1881]},"content":"200","children":[{"type":"list_item","depth":8,"payload":{"lines":[1882,1883]},"content":"请求已正常处理","children":[]}]},{"type":"list_item","depth":7,"payload":{"lines":[1884,1885]},"content":"404 Not Found","children":[{"type":"list_item","depth":8,"payload":{"lines":[1886,1887]},"content":"服务器上没有请求的资源。路径错误等","children":[]}]},{"type":"list_item","depth":7,"payload":{"lines":[1888,1889]},"content":"403 Forbidden","children":[{"type":"list_item","depth":8,"payload":{"lines":[1890,1891]},"content":"不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）","children":[]}]},{"type":"list_item","depth":7,"payload":{"lines":[1892,1893]},"content":"401 Unauthorized","children":[{"type":"list_item","depth":8,"payload":{"lines":[1894,1895]},"content":"该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。","children":[]}]},{"type":"list_item","depth":7,"payload":{"lines":[1896,1897]},"content":"400 Bad Request","children":[{"type":"list_item","depth":8,"payload":{"lines":[1898,1899]},"content":"服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误","children":[]}]},{"type":"list_item","depth":7,"payload":{"lines":[1900,1901]},"content":"500 Internal Server Error","children":[{"type":"list_item","depth":8,"payload":{"lines":[1902,1903]},"content":"该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障","children":[]}]},{"type":"list_item","depth":7,"payload":{"lines":[1904,1905]},"content":"503 Service Unavailable","children":[{"type":"list_item","depth":8,"payload":{"lines":[1906,1907]},"content":"该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求","children":[]}]},{"type":"list_item","depth":7,"payload":{"lines":[1908,1909]},"content":"302 Found","children":[{"type":"list_item","depth":8,"payload":{"lines":[1910,1911]},"content":"源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。","children":[]}]},{"type":"list_item","depth":7,"payload":{"lines":[1912,1913]},"content":"301 Moved Permanently","children":[{"type":"list_item","depth":8,"payload":{"lines":[1914,1915]},"content":"资源的uri已更新，你也更新下你的书签引用吧。永久性重定向","children":[]}]}]},{"type":"list_item","depth":6,"payload":{"lines":[1916,1917]},"content":"浏览器输⼊ URL 发⽣了什么?","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[1918,1919]},"content":"表示层","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1920,1921]},"content":"会话层","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1922,1923]},"content":"传输层","children":[{"type":"list_item","depth":5,"payload":{"lines":[1924,1925]},"content":"TCP","children":[{"type":"list_item","depth":6,"payload":{"lines":[1926,1927]},"content":"使用TCP协议前，须先建立TCP连接，形成传输数据通道","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1928,1929]},"content":"采用“三次握手”方式，点对点通信，是可靠的","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1930,1931]},"content":"在连接中可进行大数据量的传输","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1932,1933]},"content":"四次挥手","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[1934,1935]},"content":"UDP","children":[{"type":"list_item","depth":6,"payload":{"lines":[1936,1937]},"content":"将数据、源、目的封装成数据包，不需要建立连接","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1938,1939]},"content":"发送不管对方是否准备好，接收方收到也不确认，故是不可靠的","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[1940,1941]},"content":"发送数据结束时无需释放资源，开销小，速度快","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[1942,1943]},"content":"网络层","children":[{"type":"list_item","depth":5,"payload":{"lines":[1944,1945]},"content":"IP、ICMP、ARP","children":[]}]},{"type":"list_item","depth":4,"payload":{"lines":[1946,1947]},"content":"数据链路层","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1948,1949]},"content":"物理层","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1950,1951]},"content":"网卡（NIC）","children":[{"type":"list_item","depth":4,"payload":{"lines":[1952,1953]},"content":"又称网络适配器。用于计算机和网络电缆之间的物理连接。网卡完成物理层和数据链路层的大部分功能。","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1954,1955]},"content":"算法与数据结构","children":[{"type":"list_item","depth":3,"payload":{"lines":[1956,1957]},"content":"数组Array","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1958,1959]},"content":"队列Queue","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1960,1961]},"content":"栈Stack","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1962,1963]},"content":"堆Heap","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1964,1965]},"content":"哈希表Hash","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1966,1967]},"content":"字典树","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1968,1969]},"content":"二分搜索树","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1970,1971]},"content":"平衡二叉树","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1972,1973]},"content":"2-3-4树","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1974,1975]},"content":"红黑树","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1976,1977]},"content":"并查集","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1978,1979]},"content":"图","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[1980,1981]},"content":"链表","children":[{"type":"list_item","depth":4,"payload":{"lines":[1982,1983]},"content":"单向链表","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1984,1985]},"content":"双向链表","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[1986,1987]},"content":"循环链表","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[1988,1989]},"content":"排序算法","children":[{"type":"list_item","depth":4,"payload":{"lines":[1990,1991]},"content":"快速排序","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1992,1993]},"content":"数据库原理","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1994,1995]},"content":"软件工程","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[1996,1997]},"content":"开发工具","children":[{"type":"heading","depth":2,"payload":{"lines":[1998,1999]},"content":"idea","children":[]},{"type":"heading","depth":2,"payload":{"lines":[2000,2001]},"content":"Navicat","children":[]},{"type":"heading","depth":2,"payload":{"lines":[2002,2003]},"content":"xmind","children":[]},{"type":"heading","depth":2,"payload":{"lines":[2004,2005]},"content":"typora","children":[]},{"type":"heading","depth":2,"payload":{"lines":[2006,2007]},"content":"xshell","children":[]},{"type":"heading","depth":2,"payload":{"lines":[2008,2009]},"content":"xftp","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[2010,2011]},"content":"第三方库","children":[{"type":"heading","depth":2,"payload":{"lines":[2012,2013]},"content":"hutool","children":[]},{"type":"heading","depth":2,"payload":{"lines":[2014,2015]},"content":"lombok","children":[]},{"type":"heading","depth":2,"payload":{"lines":[2016,2017]},"content":"fastjson","children":[]},{"type":"heading","depth":2,"payload":{"lines":[2018,2019]},"content":"guava","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[2020,2021]},"content":"JVM","children":[{"type":"heading","depth":2,"payload":{"lines":[2022,2023]},"content":"类加载器","children":[]}]}]},null)</script>
</body>
</html>
